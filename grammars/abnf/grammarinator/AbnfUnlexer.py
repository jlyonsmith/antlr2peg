# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

charset_0 = list(chain(*multirange_diff(printable_unicode_ranges, [(62, 63)])))
charset_1 = list(chain(*multirange_diff(printable_unicode_ranges, [(92, 93),(92, 93)])))
charset_2 = list(chain(*multirange_diff(printable_unicode_ranges, [(34, 35)])))


class AbnfUnlexer(Grammarinator):

    def __init__(self, *, max_depth=float('inf'), weights=None, cooldown=1.0):
        super(AbnfUnlexer, self).__init__()
        self.unlexer = self
        self.max_depth = max_depth
        self.weights = weights or dict()
        self.cooldown = cooldown

    def EOF(self, *args, **kwargs):
        pass

    @depthcontrol
    def NumberValue(self):
        current = self.create_node(UnlexerRule(name='NumberValue'))
        current += self.create_node(UnlexerRule(src='%'))
        choice = self.choice([0 if [2, 2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_1', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_1', choice)] = self.unlexer.weights.get(('alt_1', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.BinaryValue()
        elif choice == 1:
            current += self.unlexer.DecimalValue()
        elif choice == 2:
            current += self.unlexer.HexValue()
        return current
    NumberValue.min_depth = 2

    @depthcontrol
    def BinaryValue(self):
        current = self.create_node(UnlexerRule(name='BinaryValue'))
        current += self.create_node(UnlexerRule(src='b'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.unlexer.BIT()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_7', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_7', choice)] = self.unlexer.weights.get(('alt_7', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    if self.unlexer.max_depth >= 0:
                        for _ in self.one_or_more():
                            current += self.create_node(UnlexerRule(src='.'))
                            if self.unlexer.max_depth >= 0:
                                for _ in self.one_or_more():
                                    current += self.unlexer.BIT()


                elif choice == 1:
                    current += self.create_node(UnlexerRule(src='-'))
                    if self.unlexer.max_depth >= 0:
                        for _ in self.one_or_more():
                            current += self.unlexer.BIT()


        return current
    BinaryValue.min_depth = 1

    @depthcontrol
    def DecimalValue(self):
        current = self.create_node(UnlexerRule(name='DecimalValue'))
        current += self.create_node(UnlexerRule(src='d'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.unlexer.DIGIT()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_14', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_14', choice)] = self.unlexer.weights.get(('alt_14', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    if self.unlexer.max_depth >= 0:
                        for _ in self.one_or_more():
                            current += self.create_node(UnlexerRule(src='.'))
                            if self.unlexer.max_depth >= 0:
                                for _ in self.one_or_more():
                                    current += self.unlexer.DIGIT()


                elif choice == 1:
                    current += self.create_node(UnlexerRule(src='-'))
                    if self.unlexer.max_depth >= 0:
                        for _ in self.one_or_more():
                            current += self.unlexer.DIGIT()


        return current
    DecimalValue.min_depth = 1

    @depthcontrol
    def HexValue(self):
        current = self.create_node(UnlexerRule(name='HexValue'))
        current += self.create_node(UnlexerRule(src='x'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.unlexer.HEX_DIGIT()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_21', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_21', choice)] = self.unlexer.weights.get(('alt_21', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    if self.unlexer.max_depth >= 0:
                        for _ in self.one_or_more():
                            current += self.create_node(UnlexerRule(src='.'))
                            if self.unlexer.max_depth >= 0:
                                for _ in self.one_or_more():
                                    current += self.unlexer.HEX_DIGIT()


                elif choice == 1:
                    current += self.create_node(UnlexerRule(src='-'))
                    if self.unlexer.max_depth >= 0:
                        for _ in self.one_or_more():
                            current += self.unlexer.HEX_DIGIT()


        return current
    HexValue.min_depth = 1

    @depthcontrol
    def ProseValue(self):
        current = self.create_node(UnlexerRule(name='ProseValue'))
        current += self.create_node(UnlexerRule(src='<'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += UnlexerRule(src=self.char_from_list(charset_0))

        current += self.create_node(UnlexerRule(src='>'))
        return current
    ProseValue.min_depth = 0

    @depthcontrol
    def ID(self):
        current = self.create_node(UnlexerRule(name='ID'))
        current += self.unlexer.LETTER()
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [1, 1, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_30', i), 1) for i, w in enumerate([1, 1, 1])])
                self.unlexer.weights[('alt_30', choice)] = self.unlexer.weights.get(('alt_30', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.LETTER()
                elif choice == 1:
                    current += self.unlexer.DIGIT()
                elif choice == 2:
                    current += self.create_node(UnlexerRule(src='-'))

        return current
    ID.min_depth = 1

    @depthcontrol
    def INT(self):
        current = self.create_node(UnlexerRule(name='INT'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.create_node(UnlexerRule(src=self.char_from_list(range(48, 58))))

        return current
    INT.min_depth = 0

    @depthcontrol
    def COMMENT(self):
        current = self.create_node(UnlexerRule(name='COMMENT'))
        current += self.create_node(UnlexerRule(src=';'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += UnlexerRule(src=self.char_from_list(charset_1))

        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src='\r'))

        current += self.create_node(UnlexerRule(src='\n'))
        return current
    COMMENT.min_depth = 0

    @depthcontrol
    def WS(self):
        current = self.create_node(UnlexerRule(name='WS'))
        choice = self.choice([0 if [0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_40', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_40', choice)] = self.unlexer.weights.get(('alt_40', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src=' '))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='\t'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='\r'))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='\n'))
        return current
    WS.min_depth = 0

    @depthcontrol
    def STRING(self):
        current = self.create_node(UnlexerRule(name='STRING'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_50', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_50', choice)] = self.unlexer.weights.get(('alt_50', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.create_node(UnlexerRule(src='%s'))
                elif choice == 1:
                    current += self.create_node(UnlexerRule(src='%i'))

        current += self.create_node(UnlexerRule(src='"'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += UnlexerRule(src=self.char_from_list(charset_2))

        current += self.create_node(UnlexerRule(src='"'))
        return current
    STRING.min_depth = 0

    @depthcontrol
    def LETTER(self):
        current = self.create_node(UnlexerRule(name='LETTER'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_58', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_58', choice)] = self.unlexer.weights.get(('alt_58', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src=self.char_from_list(range(97, 123))))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src=self.char_from_list(range(65, 91))))
        return current
    LETTER.min_depth = 0

    @depthcontrol
    def BIT(self):
        current = self.create_node(UnlexerRule(name='BIT'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(range(48, 50))))
        return current
    BIT.min_depth = 0

    @depthcontrol
    def DIGIT(self):
        current = self.create_node(UnlexerRule(name='DIGIT'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(range(48, 58))))
        return current
    DIGIT.min_depth = 0

    @depthcontrol
    def HEX_DIGIT(self):
        current = self.create_node(UnlexerRule(name='HEX_DIGIT'))
        choice = self.choice([0 if [0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_61', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_61', choice)] = self.unlexer.weights.get(('alt_61', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src=self.char_from_list(range(48, 58))))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src=self.char_from_list(range(97, 103))))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src=self.char_from_list(range(65, 71))))
        return current
    HEX_DIGIT.min_depth = 0


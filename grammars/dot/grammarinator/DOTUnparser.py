# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

import DOTUnlexer


class DOTUnparser(Grammarinator):

    def __init__(self, unlexer):
        super(DOTUnparser, self).__init__()
        self.unlexer = unlexer
    @depthcontrol
    def graph(self):
        current = self.create_node(UnparserRule(name='graph'))
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.STRICT()

        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_40', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_40', choice)] = self.unlexer.weights.get(('alt_40', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.GRAPH()
        elif choice == 1:
            current += self.unlexer.DIGRAPH()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.id()

        current += self.create_node(UnlexerRule(src='{'))
        current += self.stmt_list()
        current += self.create_node(UnlexerRule(src='}'))
        return current
    graph.min_depth = 1

    @depthcontrol
    def stmt_list(self):
        current = self.create_node(UnparserRule(name='stmt_list'))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.stmt()
                if self.unlexer.max_depth >= 0:
                    for _ in self.zero_or_one():
                        current += self.create_node(UnlexerRule(src=';'))


        return current
    stmt_list.min_depth = 0

    @depthcontrol
    def stmt(self):
        current = self.create_node(UnparserRule(name='stmt'))
        choice = self.choice([0 if [4, 4, 2, 2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_49', i), 1) for i, w in enumerate([1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_49', choice)] = self.unlexer.weights.get(('alt_49', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.node_stmt()
        elif choice == 1:
            current += self.edge_stmt()
        elif choice == 2:
            current += self.attr_stmt()
        elif choice == 3:
            current += self.id()
            current += self.create_node(UnlexerRule(src='='))
            current += self.id()
        elif choice == 4:
            current += self.subgraph()
        return current
    stmt.min_depth = 2

    @depthcontrol
    def attr_stmt(self):
        current = self.create_node(UnparserRule(name='attr_stmt'))
        choice = self.choice([0 if [1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_56', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_56', choice)] = self.unlexer.weights.get(('alt_56', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.GRAPH()
        elif choice == 1:
            current += self.unlexer.NODE()
        elif choice == 2:
            current += self.unlexer.EDGE()
        current += self.attr_list()
        return current
    attr_stmt.min_depth = 1

    @depthcontrol
    def attr_list(self):
        current = self.create_node(UnparserRule(name='attr_list'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.create_node(UnlexerRule(src='['))
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_one():
                        current += self.a_list()

                current += self.create_node(UnlexerRule(src=']'))

        return current
    attr_list.min_depth = 0

    @depthcontrol
    def a_list(self):
        current = self.create_node(UnparserRule(name='a_list'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.id()
                if self.unlexer.max_depth >= 2:
                    for _ in self.zero_or_one():
                        current += self.create_node(UnlexerRule(src='='))
                        current += self.id()

                if self.unlexer.max_depth >= 0:
                    for _ in self.zero_or_one():
                        current += self.create_node(UnlexerRule(src=','))


        return current
    a_list.min_depth = 2

    @depthcontrol
    def edge_stmt(self):
        current = self.create_node(UnparserRule(name='edge_stmt'))
        choice = self.choice([0 if [3, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_67', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_67', choice)] = self.unlexer.weights.get(('alt_67', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.node_id()
        elif choice == 1:
            current += self.subgraph()
        current += self.edgeRHS()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.attr_list()

        return current
    edge_stmt.min_depth = 3

    @depthcontrol
    def edgeRHS(self):
        current = self.create_node(UnparserRule(name='edgeRHS'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.edgeop()
                choice = self.choice([0 if [3, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_71', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_71', choice)] = self.unlexer.weights.get(('alt_71', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.node_id()
                elif choice == 1:
                    current += self.subgraph()

        return current
    edgeRHS.min_depth = 2

    @depthcontrol
    def edgeop(self):
        current = self.create_node(UnparserRule(name='edgeop'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_74', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_74', choice)] = self.unlexer.weights.get(('alt_74', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='->'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='--'))
        return current
    edgeop.min_depth = 0

    @depthcontrol
    def node_stmt(self):
        current = self.create_node(UnparserRule(name='node_stmt'))
        current += self.node_id()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.attr_list()

        return current
    node_stmt.min_depth = 3

    @depthcontrol
    def node_id(self):
        current = self.create_node(UnparserRule(name='node_id'))
        current += self.id()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.port()

        return current
    node_id.min_depth = 2

    @depthcontrol
    def port(self):
        current = self.create_node(UnparserRule(name='port'))
        current += self.create_node(UnlexerRule(src=':'))
        current += self.id()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src=':'))
                current += self.id()

        return current
    port.min_depth = 2

    @depthcontrol
    def subgraph(self):
        current = self.create_node(UnparserRule(name='subgraph'))
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.SUBGRAPH()
                if self.unlexer.max_depth >= 2:
                    for _ in self.zero_or_one():
                        current += self.id()


        current += self.create_node(UnlexerRule(src='{'))
        current += self.stmt_list()
        current += self.create_node(UnlexerRule(src='}'))
        return current
    subgraph.min_depth = 1

    @depthcontrol
    def id(self):
        current = self.create_node(UnparserRule(name='id'))
        choice = self.choice([0 if [2, 1, 1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_88', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_88', choice)] = self.unlexer.weights.get(('alt_88', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.ID()
        elif choice == 1:
            current += self.unlexer.STRING()
        elif choice == 2:
            current += self.unlexer.HTML_STRING()
        elif choice == 3:
            current += self.unlexer.NUMBER()
        return current
    id.min_depth = 1

    default_rule = graph


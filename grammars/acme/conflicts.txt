(1) (PUBLIC  /  PRIVATE)? (FINAL  /  ABSTRACT)? (acmePortTypeDeclaration  /  acmeRoleTypeDeclaration  /  acmeComponentTypeDeclaration  /  acmeConnectorTypeDeclaration  /  acmeGenericElementTypeDeclaration  /  acmePropertyTypeDeclaration  /  acmeGroupTypeDeclaration) / (2) acmeDesignAnalysisDeclaration  /  designRule  /  acmePortDeclaration  /  acmeRoleDeclaration  /  acmeComponentDeclaration  /  acmeConnectorDeclaration  /  acmePropertyDeclaration  /  acmeGroupDeclaration  /  acmeAttachmentDeclaration
Conflicts:
(1 , 2): { __COMPONENT, __CONNECTOR, __GROUP, __PORT, __PROPERTY, __ROLE }
Remaining Conflicts:
(1 , 2): { __COMPONENT, __CONNECTOR, __GROUP, __PORT, __PROPERTY, __ROLE }
Non-ll(1) repetition	SEMICOLON?	{ __SEMICOLON }	{ __SEMICOLON }	{ __DESIGN, __HEURISTIC, __INVARIANT, __MEMBERS, __PROPBEGIN, __PROPERTY, __RBRACE, __RULE, __SEMICOLON }	{ __DESIGN, __HEURISTIC, __INVARIANT, __MEMBERS, __PROPBEGIN, __PROPERTY, __RBRACE, __RULE, __SEMICOLON }
newNonDisjointRep	SEMICOLON?
Non-ll(1) repetition	SEMICOLON?	{ __SEMICOLON }	{ __SEMICOLON }	{ __DESIGN, __HEURISTIC, __INVARIANT, __PORT, __PROPBEGIN, __PROPERTY, __RBRACE, __REPRESENTATION, __ROLE, __RULE, __SEMICOLON }	{ __DESIGN, __HEURISTIC, __INVARIANT, __PORT, __PROPBEGIN, __PROPERTY, __RBRACE, __REPRESENTATION, __ROLE, __RULE, __SEMICOLON }
newNonDisjointRep	SEMICOLON?
Non-ll(1) repetition	(SEMICOLON acmePropertyRecordEntry)*	{ __SEMICOLON }	{ __SEMICOLON }	{ __RBRACKET, __SEMICOLON }	{ __RBRACKET, __SEMICOLON }
newNonDisjointRep	(SEMICOLON acmePropertyRecordEntry)*
Non-ll(1) repetition	(OR aSTDRImpliesExpression)*	{ __OR }	{ __OR }	{ __AND, __BIT_OR, __COMMA, __EQ, __GE, __IFF, __IMPLIES, __LANGLE, __LE, __MINUS, __NE, __OR, __PLUS, __POWER, __PROPBEGIN, __RANGLE, __RBRACE, __RBRACKET, __REM, __RPAREN, __SEMICOLON, __SLASH, __STAR }	{ __AND, __BIT_OR, __COMMA, __EQ, __GE, __IFF, __IMPLIES, __LANGLE, __LE, __MINUS, __NE, __OR, __PLUS, __POWER, __PROPBEGIN, __RANGLE, __RBRACE, __RBRACKET, __REM, __RPAREN, __SEMICOLON, __SLASH, __STAR }
newNonDisjointRep	(OR aSTDRImpliesExpression)*
Non-ll(1) repetition	(IMPLIES dRIffExpression)*	{ __IMPLIES }	{ __IMPLIES }	{ __AND, __BIT_OR, __COMMA, __EQ, __GE, __IFF, __IMPLIES, __LANGLE, __LE, __MINUS, __NE, __OR, __PLUS, __POWER, __PROPBEGIN, __RANGLE, __RBRACE, __RBRACKET, __REM, __RPAREN, __SEMICOLON, __SLASH, __STAR }	{ __AND, __BIT_OR, __COMMA, __EQ, __GE, __IFF, __IMPLIES, __LANGLE, __LE, __MINUS, __NE, __OR, __PLUS, __POWER, __PROPBEGIN, __RANGLE, __RBRACE, __RBRACKET, __REM, __RPAREN, __SEMICOLON, __SLASH, __STAR }
newNonDisjointRep	(IMPLIES dRIffExpression)*
Non-ll(1) repetition	(IFF dRAndExpression)*	{ __IFF }	{ __IFF }	{ __AND, __BIT_OR, __COMMA, __EQ, __GE, __IFF, __IMPLIES, __LANGLE, __LE, __MINUS, __NE, __OR, __PLUS, __POWER, __PROPBEGIN, __RANGLE, __RBRACE, __RBRACKET, __REM, __RPAREN, __SEMICOLON, __SLASH, __STAR }	{ __AND, __BIT_OR, __COMMA, __EQ, __GE, __IFF, __IMPLIES, __LANGLE, __LE, __MINUS, __NE, __OR, __PLUS, __POWER, __PROPBEGIN, __RANGLE, __RBRACE, __RBRACKET, __REM, __RPAREN, __SEMICOLON, __SLASH, __STAR }
newNonDisjointRep	(IFF dRAndExpression)*
Non-ll(1) repetition	(AND dRNegateExpression)*	{ __AND }	{ __AND }	{ __AND, __BIT_OR, __COMMA, __EQ, __GE, __IFF, __IMPLIES, __LANGLE, __LE, __MINUS, __NE, __OR, __PLUS, __POWER, __PROPBEGIN, __RANGLE, __RBRACE, __RBRACKET, __REM, __RPAREN, __SEMICOLON, __SLASH, __STAR }	{ __AND, __BIT_OR, __COMMA, __EQ, __GE, __IFF, __IMPLIES, __LANGLE, __LE, __MINUS, __NE, __OR, __PLUS, __POWER, __PROPBEGIN, __RANGLE, __RBRACE, __RBRACKET, __REM, __RPAREN, __SEMICOLON, __SLASH, __STAR }
newNonDisjointRep	(AND dRNegateExpression)*
Non-ll(1) repetition	(EQ dRRelationalExpression  /  NE dRRelationalExpression)*	{ __EQ, __NE }	{ __EQ, __NE }	{ __AND, __BIT_OR, __COMMA, __EQ, __GE, __IFF, __IMPLIES, __LANGLE, __LE, __MINUS, __NE, __OR, __PLUS, __POWER, __PROPBEGIN, __RANGLE, __RBRACE, __RBRACKET, __REM, __RPAREN, __SEMICOLON, __SLASH, __STAR }	{ __AND, __BIT_OR, __COMMA, __EQ, __GE, __IFF, __IMPLIES, __LANGLE, __LE, __MINUS, __NE, __OR, __PLUS, __POWER, __PROPBEGIN, __RANGLE, __RBRACE, __RBRACKET, __REM, __RPAREN, __SEMICOLON, __SLASH, __STAR }
newNonDisjointRep	(EQ dRRelationalExpression  /  NE dRRelationalExpression)*
Non-ll(1) repetition	(LANGLE dRAdditiveExpression  /  RANGLE dRAdditiveExpression  /  LE dRAdditiveExpression  /  GE dRAdditiveExpression)*	{ __GE, __LANGLE, __LE, __RANGLE }	{ __GE, __LANGLE, __LE, __RANGLE }	{ __AND, __BIT_OR, __COMMA, __EQ, __GE, __IFF, __IMPLIES, __LANGLE, __LE, __MINUS, __NE, __OR, __PLUS, __POWER, __PROPBEGIN, __RANGLE, __RBRACE, __RBRACKET, __REM, __RPAREN, __SEMICOLON, __SLASH, __STAR }	{ __AND, __BIT_OR, __COMMA, __EQ, __GE, __IFF, __IMPLIES, __LANGLE, __LE, __MINUS, __NE, __OR, __PLUS, __POWER, __PROPBEGIN, __RANGLE, __RBRACE, __RBRACKET, __REM, __RPAREN, __SEMICOLON, __SLASH, __STAR }
newNonDisjointRep	(LANGLE dRAdditiveExpression  /  RANGLE dRAdditiveExpression  /  LE dRAdditiveExpression  /  GE dRAdditiveExpression)*
Non-ll(1) repetition	(PLUS dRMultiplicativeExpression  /  MINUS dRMultiplicativeExpression)*	{ __MINUS, __PLUS }	{ __MINUS, __PLUS }	{ __AND, __BIT_OR, __COMMA, __EQ, __GE, __IFF, __IMPLIES, __LANGLE, __LE, __MINUS, __NE, __OR, __PLUS, __POWER, __PROPBEGIN, __RANGLE, __RBRACE, __RBRACKET, __REM, __RPAREN, __SEMICOLON, __SLASH, __STAR }	{ __AND, __BIT_OR, __COMMA, __EQ, __GE, __IFF, __IMPLIES, __LANGLE, __LE, __MINUS, __NE, __OR, __PLUS, __POWER, __PROPBEGIN, __RANGLE, __RBRACE, __RBRACKET, __REM, __RPAREN, __SEMICOLON, __SLASH, __STAR }
newNonDisjointRep	(PLUS dRMultiplicativeExpression  /  MINUS dRMultiplicativeExpression)*
Non-ll(1) repetition	(STAR dRNegativeExpression  /  SLASH dRNegativeExpression  /  REM dRNegativeExpression  /  POWER dRNegativeExpression)*	{ __POWER, __REM, __SLASH, __STAR }	{ __POWER, __REM, __SLASH, __STAR }	{ __AND, __BIT_OR, __COMMA, __EQ, __GE, __IFF, __IMPLIES, __LANGLE, __LE, __MINUS, __NE, __OR, __PLUS, __POWER, __PROPBEGIN, __RANGLE, __RBRACE, __RBRACKET, __REM, __RPAREN, __SEMICOLON, __SLASH, __STAR }	{ __AND, __BIT_OR, __COMMA, __EQ, __GE, __IFF, __IMPLIES, __LANGLE, __LE, __MINUS, __NE, __OR, __PLUS, __POWER, __PROPBEGIN, __RANGLE, __RBRACE, __RBRACKET, __REM, __RPAREN, __SEMICOLON, __SLASH, __STAR }
newNonDisjointRep	(STAR dRNegativeExpression  /  SLASH dRNegativeExpression  /  REM dRNegativeExpression  /  POWER dRNegativeExpression)*
Conflicting alternatives before ordering
(1) literalConstant / (2) reference / (3) parentheticalExpression / (4) setExpression / (5) literalSequence / (6) literalRecord / (7) quantifiedExpression / (8) sequenceExpression
Conflicts:
(5 , 8): { __LANGLE }
Remaining Conflicts:
(5 , 8): { __LANGLE }
Conflicting alternatives before ordering
(1) literalSet / (2) setConstructor / (3) pathExpression
Conflicts:
(1 , 2): { __LBRACE }
Remaining Conflicts:
(1 , 2): { __LBRACE }
Non-ll(1) repetition	(SLASH pathExpressionContinuation)*	{ __SLASH }	{ __SLASH }	{ __AND, __BIT_OR, __COMMA, __EQ, __GE, __IFF, __IMPLIES, __LANGLE, __LE, __MINUS, __NE, __OR, __PLUS, __POWER, __PROPBEGIN, __RANGLE, __RBRACE, __RBRACKET, __REM, __RPAREN, __SEMICOLON, __SLASH, __STAR }	{ __AND, __BIT_OR, __COMMA, __EQ, __GE, __IFF, __IMPLIES, __LANGLE, __LE, __MINUS, __NE, __OR, __PLUS, __POWER, __PROPBEGIN, __RANGLE, __RBRACE, __RBRACKET, __REM, __RPAREN, __SEMICOLON, __SLASH, __STAR }
newNonDisjointRep	(SLASH pathExpressionContinuation)*
Conflicting alternatives before ordering
(1) LBRACE RBRACE / (2) LBRACE (literalConstant  /  reference) (COMMA (literalConstant  /  reference))* RBRACE
Conflicts:
(1 , 2): { __LBRACE }
Remaining Conflicts:
(1 , 2): { __LBRACE }
Conflicting alternatives before ordering
(1) LANGLE RANGLE / (2) LANGLE (literalConstant  /  reference) (COMMA (literalConstant  /  reference))* RANGLE
Conflicts:
(1 , 2): { __LANGLE }
Remaining Conflicts:
(1 , 2): { __LANGLE }
Non-ll(1) repetition	(SEMICOLON literalRecordEntry)*	{ __SEMICOLON }	{ __SEMICOLON }	{ __RBRACKET, __SEMICOLON }	{ __RBRACKET, __SEMICOLON }
newNonDisjointRep	(SEMICOLON literalRecordEntry)*
Conflicting alternatives before ordering
(1) LBRACE? SELECT variableSetDeclaration BIT_OR designRuleExpression RBRACE? / (2) LBRACE? COLLECT reference COLON acmeTypeRef IN (setExpression  /  reference) BIT_OR designRuleExpression RBRACE?
Conflicts:
(1 , 2): { __LBRACE }
Remaining Conflicts:
(1 , 2): { __LBRACE }
Conflict stats:
Total #conflicts: 	6
Solved by #unique: 	0
Solved by #prefix: 	0
#nKey 0: 
acmeCompUnit    <-  acmeImportDeclaration* (acmeSystemDeclaration  /  acmeFamilyDeclaration  /  acmeDesignDeclaration)+ EOF
acmeImportDeclaration <-  IMPORT (filename  /  stringLiteral) SEMICOLON
stringLiteral   <-  STRING_LITERAL
filename        <-  (ZLex_001  /  ZLex_002)? IDENTIFIER ((ZLex_003  /  ZLex_004  /  ZLex_005  /  ZLex_006  /  ZLex_007  /  ZLex_008  /  ZLex_009  /  ZLex_001  /  ZLex_002)+ IDENTIFIER)*
identifier      <-  IDENTIFIER
codeLiteral     <-  STRING_LITERAL
acmeFamilyDeclaration <-  (FAMILY  /  STYLE) identifier (SEMICOLON  /  ASSIGN acmeFamilyBody SEMICOLON?  /  EXTENDS acmeFamilyRef (COMMA acmeFamilyRef)* (SEMICOLON  /  WITH acmeFamilyBody SEMICOLON?))
acmeFamilyBody  <-  LBRACE ((PUBLIC  /  PRIVATE)? (FINAL  /  ABSTRACT)? (acmePortTypeDeclaration  /  acmeRoleTypeDeclaration  /  acmeComponentTypeDeclaration  /  acmeConnectorTypeDeclaration  /  acmeGenericElementTypeDeclaration  /  acmePropertyTypeDeclaration  /  acmeGroupTypeDeclaration)  /  acmeDesignAnalysisDeclaration  /  designRule  /  acmePortDeclaration  /  acmeRoleDeclaration  /  acmeComponentDeclaration  /  acmeConnectorDeclaration  /  acmePropertyDeclaration  /  acmeGroupDeclaration  /  acmeAttachmentDeclaration)* RBRACE
acmeSystemDeclaration <-  SYSTEM identifier (COLON acmeFamilyRef (COMMA acmeFamilyRef)*)? (SEMICOLON  /  ASSIGN (acmeSystemBody SEMICOLON?  /  NEW acmeFamilyInstantiationRef (COMMA acmeFamilyInstantiationRef)* (SEMICOLON  /  EXTENDED WITH acmeSystemBody SEMICOLON?)))
acmeSystemBody  <-  LBRACE (acmePropertyDeclaration  /  acmeComponentDeclaration  /  acmeConnectorDeclaration  /  acmeAttachmentDeclaration  /  acmeGroupDeclaration  /  designRule)* RBRACE
acmeDesignDeclaration <-  DESIGN
acmeComponentTypeRef <-  identifier (DOT identifier)?
acmeComponentInstantiatedTypeRef <-  identifier (DOT identifier)?
acmeConnectorTypeRef <-  identifier (DOT identifier)?
acmeConnectorInstantiatedTypeRef <-  identifier (DOT identifier)?
acmePortTypeRef <-  identifier (DOT identifier)?
acmePortInstantiatedTypeRef <-  identifier (DOT identifier)?
acmeGroupTypeRef <-  identifier (DOT identifier)?
acmeGroupInstantiatedTypeRef <-  identifier (DOT identifier)?
acmeRoleTypeRef <-  identifier (DOT identifier)?
acmeRoleInstantiatedTypeRef <-  identifier (DOT identifier)?
acmeViewTypeRef <-  identifier (DOT identifier)?
acmeViewInstantiatedTypeRef <-  identifier (DOT identifier)?
acmeFamilyRef   <-  identifier (DOT identifier)?
acmeFamilyInstantiationRef <-  identifier
acmeElementTypeRef <-  identifier (DOT identifier)?
acmePropertyTypeDeclarationRef <-  identifier (DOT identifier)?
acmeInstanceRef <-  IDENTIFIER (DOT IDENTIFIER)*
acmeGenericElementTypeDeclaration <-  ELEMENT TYPE identifier (SEMICOLON  /  ASSIGN acmeGenericElementBody SEMICOLON?  /  EXTENDS acmeElementTypeRef (COMMA acmeElementTypeRef)* (SEMICOLON  /  WITH acmeGenericElementBody SEMICOLON?))
acmeGenericElementBody <-  LBRACE (acmePropertyDeclaration  /  designRule)* RBRACE
acmeGroupTypeDeclaration <-  GROUP TYPE identifier (SEMICOLON  /  ASSIGN acmeGroupBody SEMICOLON?  /  EXTENDS acmeGroupTypeRef (COMMA acmeGroupTypeRef)* (SEMICOLON  /  WITH acmeGroupBody SEMICOLON?))
acmeGroupDeclaration <-  GROUP identifier (COLON acmeGroupTypeRef (COMMA acmeGroupTypeRef)*)? (SEMICOLON  /  ASSIGN (acmeGroupBody SEMICOLON?  /  NEW acmeGroupInstantiatedTypeRef (COMMA acmeGroupInstantiatedTypeRef)* (SEMICOLON  /  EXTENDED WITH acmeGroupBody SEMICOLON?)))
acmeGroupBody   <-  LBRACE (acmeMembersBlock  /  acmePropertyDeclaration  /  designRule)* RBRACE
acmeMembersBlock <-  MEMBERS LBRACE (acmeInstanceRef (COMMA acmeInstanceRef)*)? RBRACE __rep_001
acmePortTypeDeclaration <-  PORT TYPE identifier (SEMICOLON  /  ASSIGN acmePortBody SEMICOLON?  /  EXTENDS acmePortTypeRef (COMMA acmePortTypeRef)* (SEMICOLON  /  WITH acmePortBody SEMICOLON?))
acmePortDeclaration <-  PORT identifier (COLON acmePortTypeRef (COMMA acmePortTypeRef)*)? (SEMICOLON?  /  ASSIGN (acmePortBody SEMICOLON?  /  NEW acmePortInstantiatedTypeRef (COMMA acmePortInstantiatedTypeRef)* (SEMICOLON  /  EXTENDED WITH acmePortBody SEMICOLON?)))
acmePortBody    <-  LBRACE (acmePropertyDeclaration  /  designRule  /  acmeRepresentationDeclaration)* RBRACE
acmeRoleTypeDeclaration <-  ROLE TYPE identifier (SEMICOLON  /  ASSIGN acmeRoleBody SEMICOLON?  /  EXTENDS acmeRoleTypeRef (COMMA acmeRoleTypeRef)* (SEMICOLON  /  WITH acmeRoleBody SEMICOLON?))
acmeRoleDeclaration <-  ROLE identifier (COLON acmeRoleTypeRef (COMMA acmeRoleTypeRef)*)? (SEMICOLON  /  ASSIGN (acmeRoleBody SEMICOLON?  /  NEW acmeRoleInstantiatedTypeRef (COMMA acmeRoleInstantiatedTypeRef)* (SEMICOLON  /  EXTENDED WITH acmeRoleBody SEMICOLON?)))
acmeRoleBody    <-  LBRACE (acmePropertyDeclaration  /  designRule  /  acmeRepresentationDeclaration)* RBRACE
acmeComponentTypeDeclaration <-  COMPONENT TYPE identifier (SEMICOLON  /  ASSIGN acmeComponentBody SEMICOLON?  /  EXTENDS acmeComponentTypeRef (COMMA acmeComponentTypeRef)* (SEMICOLON  /  WITH acmeComponentBody SEMICOLON?))
acmeComponentDeclaration <-  COMPONENT identifier (COLON acmeComponentTypeRef (COMMA acmeComponentTypeRef)*)? (SEMICOLON  /  ASSIGN (acmeComponentBody SEMICOLON?  /  NEW acmeComponentInstantiatedTypeRef (COMMA acmeComponentInstantiatedTypeRef)* (SEMICOLON  /  EXTENDED WITH acmeComponentBody SEMICOLON?)))
acmeComponentBody <-  LBRACE (acmePropertyDeclaration  /  acmePortDeclaration  /  designRule  /  acmeRepresentationDeclaration)* RBRACE
acmeConnectorTypeDeclaration <-  CONNECTOR TYPE identifier (SEMICOLON  /  ASSIGN acmeConnectorBody SEMICOLON?  /  EXTENDS acmeConnectorTypeRef (COMMA acmeConnectorTypeRef)* (SEMICOLON  /  WITH acmeConnectorBody SEMICOLON?))
acmeConnectorDeclaration <-  CONNECTOR identifier (COLON acmeConnectorTypeRef (COMMA acmeConnectorTypeRef)*)? (SEMICOLON  /  ASSIGN (acmeConnectorBody SEMICOLON?  /  NEW acmeConnectorInstantiatedTypeRef (COMMA acmeConnectorInstantiatedTypeRef)* (SEMICOLON  /  EXTENDED WITH acmeConnectorBody SEMICOLON?)))
acmeConnectorBody <-  LBRACE (acmePropertyDeclaration  /  acmeRoleDeclaration  /  designRule  /  acmeRepresentationDeclaration)* RBRACE
acmeRepresentationDeclaration <-  REPRESENTATION (IDENTIFIER ASSIGN)? LBRACE acmeSystemDeclaration acmeBindingsMapDeclaration? RBRACE __rep_002
acmeBindingsMapDeclaration <-  BINDINGS LBRACE acmeBindingDeclaration* RBRACE SEMICOLON?
acmeBindingDeclaration <-  acmeInstanceRef TO acmeInstanceRef (LBRACE acmePropertyDeclaration acmePropertyBlock RBRACE)? SEMICOLON
acmeAttachmentDeclaration <-  ATTACHMENT acmeInstanceRef TO acmeInstanceRef SEMICOLON
acmePropertyDeclaration <-  PROPERTY identifier (COLON acmePropertyTypeRef)? (ASSIGN acmePropertyValueDeclaration  /  CONTAINASSIGN acmePropertyValueDeclaration)? acmePropertyBlock? SEMICOLON
acmePropertyValueDeclaration <-  INTEGER_LITERAL  /  FLOATING_POINT_LITERAL  /  STRING_LITERAL  /  FALSE  /  TRUE  /  acmePropertySet  /  acmePropertyRecord  /  acmePropertySequence  /  enumidentifier
enumidentifier  <-  IDENTIFIER
acmePropertyElement <-  IDENTIFIER (ZLex_003 IDENTIFIER)*  /  acmePropertyCompoundElement
acmePropertyCompoundElement <-  acmePropertySet  /  acmePropertyRecord  /  acmePropertySequence
acmePropertySet <-  LBRACE (acmePropertyValueDeclaration (COMMA acmePropertyValueDeclaration)*)? RBRACE
acmePropertyRecordEntry <-  identifier (COLON acmePropertyTypeRef)? ASSIGN acmePropertyValueDeclaration
acmePropertyRecord <-  LBRACKET (acmePropertyRecordEntry __rep_003 SEMICOLON?)? RBRACKET
acmePropertySequence <-  LANGLE (acmePropertyValueDeclaration (COMMA acmePropertyValueDeclaration)*)? RANGLE
acmePropertyTypeRecord <-  RECORD LBRACKET acmePropertyRecordFieldDescription* RBRACKET
acmePropertyTypeSet <-  SET LBRACE acmeTypeRef? RBRACE
acmePropertyTypeSequence <-  SEQUENCE LANGLE acmePropertyTypeRef? RANGLE
acmePropertyTypeEnum <-  ENUM LBRACE identifier (COMMA identifier)* RBRACE
acmePropertyRecordFieldDescription <-  identifier COLON acmePropertyTypeRef SEMICOLON
acmePropertyTypeRef <-  acmePropertyTypeStructure  /  acmePropertyTypeDeclarationRef
acmePropertyTypeStructure <-  acmePropertyTypeAny  /  acmePropertyTypeInt  /  acmePropertyTypeFloat  /  acmePropertyTypeDouble  /  acmePropertyTypeString  /  acmePropertyTypeBoolean  /  acmePropertyTypeRecord  /  acmePropertyTypeSet  /  acmePropertyTypeSequence  /  acmePropertyTypeEnum
acmePropertyTypeDeclaration <-  PROPERTY TYPE identifier (SEMICOLON  /  ASSIGN (acmePropertyTypeInt  /  acmePropertyTypeFloat  /  acmePropertyTypeDouble  /  acmePropertyTypeString  /  acmePropertyTypeBoolean  /  acmePropertyTypeRecord  /  acmePropertyTypeSet  /  acmePropertyTypeSequence  /  acmePropertyTypeEnum  /  acmePropertyTypeAny) SEMICOLON)
acmePropertyBlockEntry <-  identifier (COLON acmePropertyTypeRef)? (ASSIGN acmePropertyValueDeclaration  /  CONTAINASSIGN acmePropertyValueDeclaration)? SEMICOLON
acmePropertyBlock <-  PROPBEGIN acmePropertyBlockEntry+ PROPEND
acmePropertyTypeInt <-  INT
acmePropertyTypeAny <-  ANY
acmePropertyTypeFloat <-  FLOAT
acmePropertyTypeDouble <-  DOUBLE
acmePropertyTypeString <-  STRING
acmePropertyTypeBoolean <-  BOOLEAN
acmeViewDeclaration <-  VIEW identifier (COLON acmeViewTypeRef)? (SEMICOLON  /  ASSIGN (acmeViewBody SEMICOLON?  /  NEW acmeViewInstantiatedTypeRef (SEMICOLON  /  EXTENDED WITH acmeViewBody SEMICOLON?)))
acmeViewTypeDeclaration <-  VIEW TYPE identifier (SEMICOLON  /  ASSIGN acmeViewBody SEMICOLON?  /  EXTENDS acmeViewTypeRef (SEMICOLON  /  WITH acmeViewBody SEMICOLON?))
acmeViewBody    <-  LBRACE RBRACE
designRule      <-  DESIGN? (RULE IDENTIFIER ASSIGN?)? (INVARIANT designRuleExpression  /  HEURISTIC designRuleExpression)? acmePropertyBlock? SEMICOLON
acmeDesignAnalysisDeclaration <-  DESIGN? ANALYSIS IDENTIFIER LPAREN (formalParam (COMMA formalParam)*)? RPAREN COLON acmeTypeRef ASSIGN designRuleExpression acmePropertyBlock? SEMICOLON  /  EXTERNAL DESIGN? ANALYSIS IDENTIFIER LPAREN (formalParam (COMMA formalParam)*)? RPAREN COLON acmeTypeRef ASSIGN (codeLiteral  /  identifier (DOT identifier)*) SEMICOLON
formalParam     <-  identifier COLON acmeTypeRef
terminatedDesignRuleExpression <-  designRuleExpression SEMICOLON
designRuleExpression <-  aSTDRImpliesExpression __rep_004
aSTDRImpliesExpression <-  dRIffExpression __rep_005
dRIffExpression <-  dRAndExpression __rep_006
dRAndExpression <-  dRNegateExpression __rep_007
dRNegateExpression <-  BANG dRNegateExpression  /  dREqualityExpression
dREqualityExpression <-  dRRelationalExpression __rep_008
dRRelationalExpression <-  dRAdditiveExpression __rep_009
dRAdditiveExpression <-  dRMultiplicativeExpression __rep_010
dRMultiplicativeExpression <-  dRNegativeExpression __rep_011
dRNegativeExpression <-  MINUS dRNegativeExpression  /  primitiveExpression
primitiveExpression <-  literalConstant  /  reference  /  parentheticalExpression  /  setExpression  /  literalRecord  /  quantifiedExpression  /  literalSequence  /  sequenceExpression
parentheticalExpression <-  LPAREN designRuleExpression RPAREN
reference       <-  identifier (DOT (identifier  /  setReference))* actualParams?
setReference    <-  TYPE  /  COMPONENTS  /  CONNECTORS  /  PORTS  /  ROLES  /  GROUPS  /  MEMBERS  /  PROPERTIES  /  REPRESENTATIONS  /  ATTACHEDPORTS  /  ATTACHEDROLES
actualParams    <-  LPAREN (designRuleExpression (COMMA designRuleExpression)*)? RPAREN
literalConstant <-  INTEGER_LITERAL  /  FLOATING_POINT_LITERAL  /  STRING_LITERAL  /  TRUE  /  FALSE  /  COMPONENT  /  GROUP  /  CONNECTOR  /  PORT  /  ROLE  /  SYSTEM  /  ELEMENT  /  PROPERTY  /  INT  /  FLOAT  /  DOUBLE  /  STRING  /  BOOLEAN  /  ENUM  /  SET  /  SEQUENCE  /  RECORD
quantifiedExpression <-  (FORALL  /  EXISTS UNIQUE?) variableSetDeclaration (COMMA variableSetDeclaration)* BIT_OR designRuleExpression
distinctVariableSetDeclaration <-  DISTINCT identifier (COMMA identifier)* ((COLON  /  SET_DECLARE) acmeTypeRef)? IN (setExpression  /  reference)
variableSetDeclaration <-  distinctVariableSetDeclaration  /  identifier (COMMA identifier)* ((COLON  /  SET_DECLARE) acmeTypeRef)? IN (setExpression  /  reference)
sequenceExpression <-  LANGLE pathExpression RANGLE
setExpression   <-  pathExpression  /  literalSet  /  setConstructor
pathExpression  <-  SLASH reference ((COLON  /  SET_DECLARE) acmeTypeRef)? (LBRACKET designRuleExpression RBRACKET)? __rep_012
pathExpressionContinuation <-  setReference ((COLON  /  SET_DECLARE) acmeTypeRef)? (LBRACKET designRuleExpression RBRACKET)? (SLASH pathExpressionContinuation)*  /  ELLIPSIS? reference
literalSet      <-  LBRACE RBRACE  /  LBRACE (literalConstant  /  reference) (COMMA (literalConstant  /  reference))* RBRACE
literalSequence <-  LANGLE RANGLE  /  LANGLE (literalConstant  /  reference) (COMMA (literalConstant  /  reference))* RANGLE
literalRecordEntry <-  identifier (COLON acmePropertyTypeRef)? ASSIGN literalConstant
literalRecord   <-  LBRACKET (literalRecordEntry __rep_013 SEMICOLON?)? RBRACKET
setConstructor  <-  LBRACE? SELECT variableSetDeclaration BIT_OR designRuleExpression RBRACE?  /  LBRACE? COLLECT reference COLON acmeTypeRef IN (setExpression  /  reference) BIT_OR designRuleExpression RBRACE?
acmeTypeRef     <-  SYSTEM  /  COMPONENT  /  GROUP  /  CONNECTOR  /  PORT  /  ROLE  /  PROPERTY  /  ELEMENT  /  TYPE  /  REPRESENTATION  /  reference  /  acmePropertyTypeStructure
ABSTRACT        <-  A B S T R A C T
ANALYSIS        <-  A N A L Y S I S
AND             <-  A N D
ANY             <-  A N Y
ASSIGN          <-  '='
ATTACHMENT      <-  A T T A C H M E N T
ATTACHMENTS     <-  A T T A C H M E N T S
ATTACHEDPORTS   <-  A T T A C H E D P O R T S
ATTACHEDROLES   <-  A T T A C H E D R O L E S
BANG            <-  '!'
BINDINGS        <-  B I N D I N G S
COLON           <-  ':'
COMMA           <-  ','
COLLECT         <-  C O L L E C T
COMPONENT       <-  C O M P O N E N T
COMPONENTS      <-  C O M P O N E N T S
CONNECTOR       <-  C O N N E C T O R
CONTAINASSIGN   <-  C O N T A I N A S S I G N
CONNECTORS      <-  C O N N E C T O R S
DESIGN          <-  D E S I G N
DISTINCT        <-  D I S T I N C T
DOT             <-  '.'
DOUBLE          <-  D O U B L E
ELEMENT         <-  E L E M E N T
ENUM            <-  E N U M
EXTENDED        <-  E X T E N D E D
EXTENDS         <-  E X T E N D S
EXTERNAL        <-  E X T E R N A L
EXISTS          <-  E X I S T S
ELLIPSIS        <-  '...'
EQ              <-  '=='
FAMILY          <-  F A M I L Y
FINAL           <-  F I N A L
FORALL          <-  F O R A L L
FLOAT           <-  F L O A T
GROUP           <-  G R O U P
GROUPS          <-  G R O U P S
GE              <-  '>='
HEURISTIC       <-  H E U R I S T I C
IFF             <-  '<->'
IMPORT          <-  I M P O R T
IN              <-  I N
INT             <-  I N T  /  I N T E G E R
INVARIANT       <-  I N V A R I A N T
IMPLIES         <-  '->'
LBRACE          <-  '{'
RBRACE          <-  '}'
LBRACKET        <-  '['
RBRACKET        <-  ']'
LPAREN          <-  '('
RPAREN          <-  ')'
LANGLE          <-  '<'
RANGLE          <-  '>'
LE              <-  '<='
NE              <-  '!='
NEW             <-  N E W
MEMBERS         <-  M E M B E R S
MINUS           <-  '-'
OR              <-  O R
PATHSEPARATOR   <-  '.'  /  ':'  /  '-'  /  '+'  /  '\\'  /  '\\\\'  /  '/'  /  '$'  /  '%'
PUBLIC          <-  P U B L I C
PRIVATE         <-  P R I V A T E
POWER           <-  P O W E R
PLUS            <-  '+'
PORT            <-  P O R T
PORTS           <-  P O R T S
PROPERTY        <-  P R O P E R T Y
PROPERTIES      <-  P R O P E R T I E S
PROPBEGIN       <-  '<<'
PROPEND         <-  '>>'
RECORD          <-  R E C O R D
REPRESENTATION  <-  R E P R E S E N T A T I O N
REM             <-  '%'
REPRESENTATIONS <-  R E P R E S E N T A T I O N S
ROLE            <-  R O L E
RULE            <-  R U L E
ROLES           <-  R O L E S
SEQUENCE        <-  S E Q U E N C E  /  S E Q
SELECT          <-  S E L E C T
SEMICOLON       <-  ';'
SET             <-  S E T
SET_DECLARE     <-  ':!'
SLASH           <-  '/'
STAR            <-  '*'
STRING          <-  S T R I N G
STYLE           <-  S T Y L E
SYSTEM          <-  S Y S T E M
TO              <-  T O
TYPE            <-  T Y P E
UNIQUE          <-  U N I Q U E
WITH            <-  W I T H
VIEW            <-  V I E W
BIT_OR          <-  '|'
TRUE            <-  T R U E
FALSE           <-  F A L S E
A               <-  'a'  /  'A'
B               <-  'b'  /  'B'
C               <-  'c'  /  'C'
D               <-  'd'  /  'D'
E               <-  'e'  /  'E'
F               <-  'f'  /  'F'
G               <-  'g'  /  'G'
H               <-  'h'  /  'H'
I               <-  'i'  /  'I'
J               <-  'j'  /  'J'
K               <-  'k'  /  'K'
L               <-  'l'  /  'L'
M               <-  'm'  /  'M'
N               <-  'n'  /  'N'
O               <-  'o'  /  'O'
P               <-  'p'  /  'P'
Q               <-  'q'  /  'Q'
R               <-  'r'  /  'R'
S               <-  's'  /  'S'
T               <-  't'  /  'T'
U               <-  'u'  /  'U'
V               <-  'v'  /  'V'
W               <-  'w'  /  'W'
X               <-  'x'  /  'X'
Y               <-  'y'  /  'Y'
Z               <-  'z'  /  'Z'
BOOLEAN         <-  TRUE  /  FALSE
FLOATING_POINT_LITERAL <-  ('-'  /  '+')? [0-9]+ '.' [0-9]+
INTEGER_LITERAL <-  [0-9]+
STRING_LITERAL  <-  '"' (!'"' .)* '"'
IDENTIFIER      <-  [a-zA-Z] [a-zA-Z0-9_-]*
LINE_COMMENT    <-  '//' (![\r\n] .)*
BLOCK_COMMENT   <-  '/*' (!'*/' .)* '*/'
WS              <-  [ \r\n\t]+
EOF             <-  !.
__rep_001       <-  SEMICOLON &(DESIGN  /  HEURISTIC  /  INVARIANT  /  MEMBERS  /  PROPBEGIN  /  PROPERTY  /  RBRACE  /  RULE  /  SEMICOLON)  /  ''
__rep_002       <-  SEMICOLON &(DESIGN  /  HEURISTIC  /  INVARIANT  /  PORT  /  PROPBEGIN  /  PROPERTY  /  RBRACE  /  REPRESENTATION  /  ROLE  /  RULE  /  SEMICOLON)  /  ''
__rep_003       <-  SEMICOLON acmePropertyRecordEntry __rep_003  /  &(RBRACKET  /  SEMICOLON)
__rep_004       <-  OR aSTDRImpliesExpression __rep_004  /  &(AND  /  BIT_OR  /  COMMA  /  EQ  /  GE  /  IFF  /  IMPLIES  /  LANGLE  /  LE  /  MINUS  /  NE  /  OR  /  PLUS  /  POWER  /  PROPBEGIN  /  RANGLE  /  RBRACE  /  RBRACKET  /  REM  /  RPAREN  /  SEMICOLON  /  SLASH  /  STAR)
__rep_005       <-  IMPLIES dRIffExpression __rep_005  /  &(AND  /  BIT_OR  /  COMMA  /  EQ  /  GE  /  IFF  /  IMPLIES  /  LANGLE  /  LE  /  MINUS  /  NE  /  OR  /  PLUS  /  POWER  /  PROPBEGIN  /  RANGLE  /  RBRACE  /  RBRACKET  /  REM  /  RPAREN  /  SEMICOLON  /  SLASH  /  STAR)
__rep_006       <-  IFF dRAndExpression __rep_006  /  &(AND  /  BIT_OR  /  COMMA  /  EQ  /  GE  /  IFF  /  IMPLIES  /  LANGLE  /  LE  /  MINUS  /  NE  /  OR  /  PLUS  /  POWER  /  PROPBEGIN  /  RANGLE  /  RBRACE  /  RBRACKET  /  REM  /  RPAREN  /  SEMICOLON  /  SLASH  /  STAR)
__rep_007       <-  AND dRNegateExpression __rep_007  /  &(AND  /  BIT_OR  /  COMMA  /  EQ  /  GE  /  IFF  /  IMPLIES  /  LANGLE  /  LE  /  MINUS  /  NE  /  OR  /  PLUS  /  POWER  /  PROPBEGIN  /  RANGLE  /  RBRACE  /  RBRACKET  /  REM  /  RPAREN  /  SEMICOLON  /  SLASH  /  STAR)
__rep_008       <-  (EQ dRRelationalExpression  /  NE dRRelationalExpression) __rep_008  /  &(AND  /  BIT_OR  /  COMMA  /  EQ  /  GE  /  IFF  /  IMPLIES  /  LANGLE  /  LE  /  MINUS  /  NE  /  OR  /  PLUS  /  POWER  /  PROPBEGIN  /  RANGLE  /  RBRACE  /  RBRACKET  /  REM  /  RPAREN  /  SEMICOLON  /  SLASH  /  STAR)
__rep_009       <-  (LANGLE dRAdditiveExpression  /  RANGLE dRAdditiveExpression  /  LE dRAdditiveExpression  /  GE dRAdditiveExpression) __rep_009  /  &(AND  /  BIT_OR  /  COMMA  /  EQ  /  GE  /  IFF  /  IMPLIES  /  LANGLE  /  LE  /  MINUS  /  NE  /  OR  /  PLUS  /  POWER  /  PROPBEGIN  /  RANGLE  /  RBRACE  /  RBRACKET  /  REM  /  RPAREN  /  SEMICOLON  /  SLASH  /  STAR)
__rep_010       <-  (PLUS dRMultiplicativeExpression  /  MINUS dRMultiplicativeExpression) __rep_010  /  &(AND  /  BIT_OR  /  COMMA  /  EQ  /  GE  /  IFF  /  IMPLIES  /  LANGLE  /  LE  /  MINUS  /  NE  /  OR  /  PLUS  /  POWER  /  PROPBEGIN  /  RANGLE  /  RBRACE  /  RBRACKET  /  REM  /  RPAREN  /  SEMICOLON  /  SLASH  /  STAR)
__rep_011       <-  (STAR dRNegativeExpression  /  SLASH dRNegativeExpression  /  REM dRNegativeExpression  /  POWER dRNegativeExpression) __rep_011  /  &(AND  /  BIT_OR  /  COMMA  /  EQ  /  GE  /  IFF  /  IMPLIES  /  LANGLE  /  LE  /  MINUS  /  NE  /  OR  /  PLUS  /  POWER  /  PROPBEGIN  /  RANGLE  /  RBRACE  /  RBRACKET  /  REM  /  RPAREN  /  SEMICOLON  /  SLASH  /  STAR)
__rep_012       <-  SLASH pathExpressionContinuation __rep_012  /  &(AND  /  BIT_OR  /  COMMA  /  EQ  /  GE  /  IFF  /  IMPLIES  /  LANGLE  /  LE  /  MINUS  /  NE  /  OR  /  PLUS  /  POWER  /  PROPBEGIN  /  RANGLE  /  RBRACE  /  RBRACKET  /  REM  /  RPAREN  /  SEMICOLON  /  SLASH  /  STAR)
__rep_013       <-  SEMICOLON literalRecordEntry __rep_013  /  &(RBRACKET  /  SEMICOLON)
__IdBegin       <-  [a-zA-Z]
__IdRest        <-  [a-zA-Z0-9_-]
ZLex_001        <-  '$'
ZLex_002        <-  '%'
ZLex_003        <-  '.'
ZLex_004        <-  ':'
ZLex_005        <-  '-'
ZLex_006        <-  '+'
ZLex_007        <-  '\\'
ZLex_008        <-  '\\\\'
ZLex_009        <-  '/'


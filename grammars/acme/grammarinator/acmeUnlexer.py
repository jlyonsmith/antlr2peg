# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

charset_0 = list(chain(range(48, 58)))
charset_1 = list(chain(range(48, 58)))
charset_2 = list(chain(range(48, 58)))
charset_3 = list(chain(range(97, 123), range(65, 91)))
charset_4 = list(chain(range(97, 123), range(65, 91), range(48, 58), range(95, 96), range(45, 46)))
charset_5 = list(chain(*multirange_diff(printable_unicode_ranges, [(10, 11),(13, 14)])))
charset_6 = list(chain(range(32, 33), range(13, 14), range(10, 11), range(9, 10)))


class acmeUnlexer(Grammarinator):

    def __init__(self, *, max_depth=float('inf'), weights=None, cooldown=1.0):
        super(acmeUnlexer, self).__init__()
        self.unlexer = self
        self.max_depth = max_depth
        self.weights = weights or dict()
        self.cooldown = cooldown

    def EOF(self, *args, **kwargs):
        pass

    @depthcontrol
    def ABSTRACT(self):
        current = self.create_node(UnlexerRule(name='ABSTRACT'))
        current += self.unlexer.A()
        current += self.unlexer.B()
        current += self.unlexer.S()
        current += self.unlexer.T()
        current += self.unlexer.R()
        current += self.unlexer.A()
        current += self.unlexer.C()
        current += self.unlexer.T()
        return current
    ABSTRACT.min_depth = 1

    @depthcontrol
    def ANALYSIS(self):
        current = self.create_node(UnlexerRule(name='ANALYSIS'))
        current += self.unlexer.A()
        current += self.unlexer.N()
        current += self.unlexer.A()
        current += self.unlexer.L()
        current += self.unlexer.Y()
        current += self.unlexer.S()
        current += self.unlexer.I()
        current += self.unlexer.S()
        return current
    ANALYSIS.min_depth = 1

    @depthcontrol
    def AND(self):
        current = self.create_node(UnlexerRule(name='AND'))
        current += self.unlexer.A()
        current += self.unlexer.N()
        current += self.unlexer.D()
        return current
    AND.min_depth = 1

    @depthcontrol
    def ANY(self):
        current = self.create_node(UnlexerRule(name='ANY'))
        current += self.unlexer.A()
        current += self.unlexer.N()
        current += self.unlexer.Y()
        return current
    ANY.min_depth = 1

    @depthcontrol
    def ASSIGN(self):
        current = self.create_node(UnlexerRule(name='ASSIGN'))
        current += self.create_node(UnlexerRule(src='='))
        return current
    ASSIGN.min_depth = 0

    @depthcontrol
    def ATTACHMENT(self):
        current = self.create_node(UnlexerRule(name='ATTACHMENT'))
        current += self.unlexer.A()
        current += self.unlexer.T()
        current += self.unlexer.T()
        current += self.unlexer.A()
        current += self.unlexer.C()
        current += self.unlexer.H()
        current += self.unlexer.M()
        current += self.unlexer.E()
        current += self.unlexer.N()
        current += self.unlexer.T()
        return current
    ATTACHMENT.min_depth = 1

    @depthcontrol
    def ATTACHMENTS(self):
        current = self.create_node(UnlexerRule(name='ATTACHMENTS'))
        current += self.unlexer.A()
        current += self.unlexer.T()
        current += self.unlexer.T()
        current += self.unlexer.A()
        current += self.unlexer.C()
        current += self.unlexer.H()
        current += self.unlexer.M()
        current += self.unlexer.E()
        current += self.unlexer.N()
        current += self.unlexer.T()
        current += self.unlexer.S()
        return current
    ATTACHMENTS.min_depth = 1

    @depthcontrol
    def ATTACHEDPORTS(self):
        current = self.create_node(UnlexerRule(name='ATTACHEDPORTS'))
        current += self.unlexer.A()
        current += self.unlexer.T()
        current += self.unlexer.T()
        current += self.unlexer.A()
        current += self.unlexer.C()
        current += self.unlexer.H()
        current += self.unlexer.E()
        current += self.unlexer.D()
        current += self.unlexer.P()
        current += self.unlexer.O()
        current += self.unlexer.R()
        current += self.unlexer.T()
        current += self.unlexer.S()
        return current
    ATTACHEDPORTS.min_depth = 1

    @depthcontrol
    def ATTACHEDROLES(self):
        current = self.create_node(UnlexerRule(name='ATTACHEDROLES'))
        current += self.unlexer.A()
        current += self.unlexer.T()
        current += self.unlexer.T()
        current += self.unlexer.A()
        current += self.unlexer.C()
        current += self.unlexer.H()
        current += self.unlexer.E()
        current += self.unlexer.D()
        current += self.unlexer.R()
        current += self.unlexer.O()
        current += self.unlexer.L()
        current += self.unlexer.E()
        current += self.unlexer.S()
        return current
    ATTACHEDROLES.min_depth = 1

    @depthcontrol
    def BANG(self):
        current = self.create_node(UnlexerRule(name='BANG'))
        current += self.create_node(UnlexerRule(src='!'))
        return current
    BANG.min_depth = 0

    @depthcontrol
    def BINDINGS(self):
        current = self.create_node(UnlexerRule(name='BINDINGS'))
        current += self.unlexer.B()
        current += self.unlexer.I()
        current += self.unlexer.N()
        current += self.unlexer.D()
        current += self.unlexer.I()
        current += self.unlexer.N()
        current += self.unlexer.G()
        current += self.unlexer.S()
        return current
    BINDINGS.min_depth = 1

    @depthcontrol
    def COLON(self):
        current = self.create_node(UnlexerRule(name='COLON'))
        current += self.create_node(UnlexerRule(src=':'))
        return current
    COLON.min_depth = 0

    @depthcontrol
    def COMMA(self):
        current = self.create_node(UnlexerRule(name='COMMA'))
        current += self.create_node(UnlexerRule(src=','))
        return current
    COMMA.min_depth = 0

    @depthcontrol
    def COLLECT(self):
        current = self.create_node(UnlexerRule(name='COLLECT'))
        current += self.unlexer.C()
        current += self.unlexer.O()
        current += self.unlexer.L()
        current += self.unlexer.L()
        current += self.unlexer.E()
        current += self.unlexer.C()
        current += self.unlexer.T()
        return current
    COLLECT.min_depth = 1

    @depthcontrol
    def COMPONENT(self):
        current = self.create_node(UnlexerRule(name='COMPONENT'))
        current += self.unlexer.C()
        current += self.unlexer.O()
        current += self.unlexer.M()
        current += self.unlexer.P()
        current += self.unlexer.O()
        current += self.unlexer.N()
        current += self.unlexer.E()
        current += self.unlexer.N()
        current += self.unlexer.T()
        return current
    COMPONENT.min_depth = 1

    @depthcontrol
    def COMPONENTS(self):
        current = self.create_node(UnlexerRule(name='COMPONENTS'))
        current += self.unlexer.C()
        current += self.unlexer.O()
        current += self.unlexer.M()
        current += self.unlexer.P()
        current += self.unlexer.O()
        current += self.unlexer.N()
        current += self.unlexer.E()
        current += self.unlexer.N()
        current += self.unlexer.T()
        current += self.unlexer.S()
        return current
    COMPONENTS.min_depth = 1

    @depthcontrol
    def CONNECTOR(self):
        current = self.create_node(UnlexerRule(name='CONNECTOR'))
        current += self.unlexer.C()
        current += self.unlexer.O()
        current += self.unlexer.N()
        current += self.unlexer.N()
        current += self.unlexer.E()
        current += self.unlexer.C()
        current += self.unlexer.T()
        current += self.unlexer.O()
        current += self.unlexer.R()
        return current
    CONNECTOR.min_depth = 1

    @depthcontrol
    def CONTAINASSIGN(self):
        current = self.create_node(UnlexerRule(name='CONTAINASSIGN'))
        current += self.unlexer.C()
        current += self.unlexer.O()
        current += self.unlexer.N()
        current += self.unlexer.T()
        current += self.unlexer.A()
        current += self.unlexer.I()
        current += self.unlexer.N()
        current += self.unlexer.A()
        current += self.unlexer.S()
        current += self.unlexer.S()
        current += self.unlexer.I()
        current += self.unlexer.G()
        current += self.unlexer.N()
        return current
    CONTAINASSIGN.min_depth = 1

    @depthcontrol
    def CONNECTORS(self):
        current = self.create_node(UnlexerRule(name='CONNECTORS'))
        current += self.unlexer.C()
        current += self.unlexer.O()
        current += self.unlexer.N()
        current += self.unlexer.N()
        current += self.unlexer.E()
        current += self.unlexer.C()
        current += self.unlexer.T()
        current += self.unlexer.O()
        current += self.unlexer.R()
        current += self.unlexer.S()
        return current
    CONNECTORS.min_depth = 1

    @depthcontrol
    def DESIGN(self):
        current = self.create_node(UnlexerRule(name='DESIGN'))
        current += self.unlexer.D()
        current += self.unlexer.E()
        current += self.unlexer.S()
        current += self.unlexer.I()
        current += self.unlexer.G()
        current += self.unlexer.N()
        return current
    DESIGN.min_depth = 1

    @depthcontrol
    def DISTINCT(self):
        current = self.create_node(UnlexerRule(name='DISTINCT'))
        current += self.unlexer.D()
        current += self.unlexer.I()
        current += self.unlexer.S()
        current += self.unlexer.T()
        current += self.unlexer.I()
        current += self.unlexer.N()
        current += self.unlexer.C()
        current += self.unlexer.T()
        return current
    DISTINCT.min_depth = 1

    @depthcontrol
    def DOT(self):
        current = self.create_node(UnlexerRule(name='DOT'))
        current += self.create_node(UnlexerRule(src='.'))
        return current
    DOT.min_depth = 0

    @depthcontrol
    def DOUBLE(self):
        current = self.create_node(UnlexerRule(name='DOUBLE'))
        current += self.unlexer.D()
        current += self.unlexer.O()
        current += self.unlexer.U()
        current += self.unlexer.B()
        current += self.unlexer.L()
        current += self.unlexer.E()
        return current
    DOUBLE.min_depth = 1

    @depthcontrol
    def ELEMENT(self):
        current = self.create_node(UnlexerRule(name='ELEMENT'))
        current += self.unlexer.E()
        current += self.unlexer.L()
        current += self.unlexer.E()
        current += self.unlexer.M()
        current += self.unlexer.E()
        current += self.unlexer.N()
        current += self.unlexer.T()
        return current
    ELEMENT.min_depth = 1

    @depthcontrol
    def ENUM(self):
        current = self.create_node(UnlexerRule(name='ENUM'))
        current += self.unlexer.E()
        current += self.unlexer.N()
        current += self.unlexer.U()
        current += self.unlexer.M()
        return current
    ENUM.min_depth = 1

    @depthcontrol
    def EXTENDED(self):
        current = self.create_node(UnlexerRule(name='EXTENDED'))
        current += self.unlexer.E()
        current += self.unlexer.X()
        current += self.unlexer.T()
        current += self.unlexer.E()
        current += self.unlexer.N()
        current += self.unlexer.D()
        current += self.unlexer.E()
        current += self.unlexer.D()
        return current
    EXTENDED.min_depth = 1

    @depthcontrol
    def EXTENDS(self):
        current = self.create_node(UnlexerRule(name='EXTENDS'))
        current += self.unlexer.E()
        current += self.unlexer.X()
        current += self.unlexer.T()
        current += self.unlexer.E()
        current += self.unlexer.N()
        current += self.unlexer.D()
        current += self.unlexer.S()
        return current
    EXTENDS.min_depth = 1

    @depthcontrol
    def EXTERNAL(self):
        current = self.create_node(UnlexerRule(name='EXTERNAL'))
        current += self.unlexer.E()
        current += self.unlexer.X()
        current += self.unlexer.T()
        current += self.unlexer.E()
        current += self.unlexer.R()
        current += self.unlexer.N()
        current += self.unlexer.A()
        current += self.unlexer.L()
        return current
    EXTERNAL.min_depth = 1

    @depthcontrol
    def EXISTS(self):
        current = self.create_node(UnlexerRule(name='EXISTS'))
        current += self.unlexer.E()
        current += self.unlexer.X()
        current += self.unlexer.I()
        current += self.unlexer.S()
        current += self.unlexer.T()
        current += self.unlexer.S()
        return current
    EXISTS.min_depth = 1

    @depthcontrol
    def ELLIPSIS(self):
        current = self.create_node(UnlexerRule(name='ELLIPSIS'))
        current += self.create_node(UnlexerRule(src='...'))
        return current
    ELLIPSIS.min_depth = 0

    @depthcontrol
    def EQ(self):
        current = self.create_node(UnlexerRule(name='EQ'))
        current += self.create_node(UnlexerRule(src='=='))
        return current
    EQ.min_depth = 0

    @depthcontrol
    def FAMILY(self):
        current = self.create_node(UnlexerRule(name='FAMILY'))
        current += self.unlexer.F()
        current += self.unlexer.A()
        current += self.unlexer.M()
        current += self.unlexer.I()
        current += self.unlexer.L()
        current += self.unlexer.Y()
        return current
    FAMILY.min_depth = 1

    @depthcontrol
    def FINAL(self):
        current = self.create_node(UnlexerRule(name='FINAL'))
        current += self.unlexer.F()
        current += self.unlexer.I()
        current += self.unlexer.N()
        current += self.unlexer.A()
        current += self.unlexer.L()
        return current
    FINAL.min_depth = 1

    @depthcontrol
    def FORALL(self):
        current = self.create_node(UnlexerRule(name='FORALL'))
        current += self.unlexer.F()
        current += self.unlexer.O()
        current += self.unlexer.R()
        current += self.unlexer.A()
        current += self.unlexer.L()
        current += self.unlexer.L()
        return current
    FORALL.min_depth = 1

    @depthcontrol
    def FLOAT(self):
        current = self.create_node(UnlexerRule(name='FLOAT'))
        current += self.unlexer.F()
        current += self.unlexer.L()
        current += self.unlexer.O()
        current += self.unlexer.A()
        current += self.unlexer.T()
        return current
    FLOAT.min_depth = 1

    @depthcontrol
    def GROUP(self):
        current = self.create_node(UnlexerRule(name='GROUP'))
        current += self.unlexer.G()
        current += self.unlexer.R()
        current += self.unlexer.O()
        current += self.unlexer.U()
        current += self.unlexer.P()
        return current
    GROUP.min_depth = 1

    @depthcontrol
    def GROUPS(self):
        current = self.create_node(UnlexerRule(name='GROUPS'))
        current += self.unlexer.G()
        current += self.unlexer.R()
        current += self.unlexer.O()
        current += self.unlexer.U()
        current += self.unlexer.P()
        current += self.unlexer.S()
        return current
    GROUPS.min_depth = 1

    @depthcontrol
    def GE(self):
        current = self.create_node(UnlexerRule(name='GE'))
        current += self.create_node(UnlexerRule(src='>='))
        return current
    GE.min_depth = 0

    @depthcontrol
    def HEURISTIC(self):
        current = self.create_node(UnlexerRule(name='HEURISTIC'))
        current += self.unlexer.H()
        current += self.unlexer.E()
        current += self.unlexer.U()
        current += self.unlexer.R()
        current += self.unlexer.I()
        current += self.unlexer.S()
        current += self.unlexer.T()
        current += self.unlexer.I()
        current += self.unlexer.C()
        return current
    HEURISTIC.min_depth = 1

    @depthcontrol
    def IFF(self):
        current = self.create_node(UnlexerRule(name='IFF'))
        current += self.create_node(UnlexerRule(src='<->'))
        return current
    IFF.min_depth = 0

    @depthcontrol
    def IMPORT(self):
        current = self.create_node(UnlexerRule(name='IMPORT'))
        current += self.unlexer.I()
        current += self.unlexer.M()
        current += self.unlexer.P()
        current += self.unlexer.O()
        current += self.unlexer.R()
        current += self.unlexer.T()
        return current
    IMPORT.min_depth = 1

    @depthcontrol
    def IN(self):
        current = self.create_node(UnlexerRule(name='IN'))
        current += self.unlexer.I()
        current += self.unlexer.N()
        return current
    IN.min_depth = 1

    @depthcontrol
    def INT(self):
        current = self.create_node(UnlexerRule(name='INT'))
        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_9', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_9', choice)] = self.unlexer.weights.get(('alt_9', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.I()
            current += self.unlexer.N()
            current += self.unlexer.T()
        elif choice == 1:
            current += self.unlexer.I()
            current += self.unlexer.N()
            current += self.unlexer.T()
            current += self.unlexer.E()
            current += self.unlexer.G()
            current += self.unlexer.E()
            current += self.unlexer.R()
        return current
    INT.min_depth = 1

    @depthcontrol
    def INVARIANT(self):
        current = self.create_node(UnlexerRule(name='INVARIANT'))
        current += self.unlexer.I()
        current += self.unlexer.N()
        current += self.unlexer.V()
        current += self.unlexer.A()
        current += self.unlexer.R()
        current += self.unlexer.I()
        current += self.unlexer.A()
        current += self.unlexer.N()
        current += self.unlexer.T()
        return current
    INVARIANT.min_depth = 1

    @depthcontrol
    def IMPLIES(self):
        current = self.create_node(UnlexerRule(name='IMPLIES'))
        current += self.create_node(UnlexerRule(src='->'))
        return current
    IMPLIES.min_depth = 0

    @depthcontrol
    def LBRACE(self):
        current = self.create_node(UnlexerRule(name='LBRACE'))
        current += self.create_node(UnlexerRule(src='{'))
        return current
    LBRACE.min_depth = 0

    @depthcontrol
    def RBRACE(self):
        current = self.create_node(UnlexerRule(name='RBRACE'))
        current += self.create_node(UnlexerRule(src='}'))
        return current
    RBRACE.min_depth = 0

    @depthcontrol
    def LBRACKET(self):
        current = self.create_node(UnlexerRule(name='LBRACKET'))
        current += self.create_node(UnlexerRule(src='['))
        return current
    LBRACKET.min_depth = 0

    @depthcontrol
    def RBRACKET(self):
        current = self.create_node(UnlexerRule(name='RBRACKET'))
        current += self.create_node(UnlexerRule(src=']'))
        return current
    RBRACKET.min_depth = 0

    @depthcontrol
    def LPAREN(self):
        current = self.create_node(UnlexerRule(name='LPAREN'))
        current += self.create_node(UnlexerRule(src='('))
        return current
    LPAREN.min_depth = 0

    @depthcontrol
    def RPAREN(self):
        current = self.create_node(UnlexerRule(name='RPAREN'))
        current += self.create_node(UnlexerRule(src=')'))
        return current
    RPAREN.min_depth = 0

    @depthcontrol
    def LANGLE(self):
        current = self.create_node(UnlexerRule(name='LANGLE'))
        current += self.create_node(UnlexerRule(src='<'))
        return current
    LANGLE.min_depth = 0

    @depthcontrol
    def RANGLE(self):
        current = self.create_node(UnlexerRule(name='RANGLE'))
        current += self.create_node(UnlexerRule(src='>'))
        return current
    RANGLE.min_depth = 0

    @depthcontrol
    def LE(self):
        current = self.create_node(UnlexerRule(name='LE'))
        current += self.create_node(UnlexerRule(src='<='))
        return current
    LE.min_depth = 0

    @depthcontrol
    def NE(self):
        current = self.create_node(UnlexerRule(name='NE'))
        current += self.create_node(UnlexerRule(src='!='))
        return current
    NE.min_depth = 0

    @depthcontrol
    def NEW(self):
        current = self.create_node(UnlexerRule(name='NEW'))
        current += self.unlexer.N()
        current += self.unlexer.E()
        current += self.unlexer.W()
        return current
    NEW.min_depth = 1

    @depthcontrol
    def MEMBERS(self):
        current = self.create_node(UnlexerRule(name='MEMBERS'))
        current += self.unlexer.M()
        current += self.unlexer.E()
        current += self.unlexer.M()
        current += self.unlexer.B()
        current += self.unlexer.E()
        current += self.unlexer.R()
        current += self.unlexer.S()
        return current
    MEMBERS.min_depth = 1

    @depthcontrol
    def MINUS(self):
        current = self.create_node(UnlexerRule(name='MINUS'))
        current += self.create_node(UnlexerRule(src='-'))
        return current
    MINUS.min_depth = 0

    @depthcontrol
    def OR(self):
        current = self.create_node(UnlexerRule(name='OR'))
        current += self.unlexer.O()
        current += self.unlexer.R()
        return current
    OR.min_depth = 1

    @depthcontrol
    def PATHSEPARATOR(self):
        current = self.create_node(UnlexerRule(name='PATHSEPARATOR'))
        choice = self.choice([0 if [0, 0, 0, 0, 0, 0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_24', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_24', choice)] = self.unlexer.weights.get(('alt_24', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='.'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src=':'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='-'))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='+'))
        elif choice == 4:
            current += self.create_node(UnlexerRule(src='\\'))
        elif choice == 5:
            current += self.create_node(UnlexerRule(src='\\\\'))
        elif choice == 6:
            current += self.create_node(UnlexerRule(src='/'))
        elif choice == 7:
            current += self.create_node(UnlexerRule(src='$'))
        elif choice == 8:
            current += self.create_node(UnlexerRule(src='%'))
        return current
    PATHSEPARATOR.min_depth = 0

    @depthcontrol
    def PUBLIC(self):
        current = self.create_node(UnlexerRule(name='PUBLIC'))
        current += self.unlexer.P()
        current += self.unlexer.U()
        current += self.unlexer.B()
        current += self.unlexer.L()
        current += self.unlexer.I()
        current += self.unlexer.C()
        return current
    PUBLIC.min_depth = 1

    @depthcontrol
    def PRIVATE(self):
        current = self.create_node(UnlexerRule(name='PRIVATE'))
        current += self.unlexer.P()
        current += self.unlexer.R()
        current += self.unlexer.I()
        current += self.unlexer.V()
        current += self.unlexer.A()
        current += self.unlexer.T()
        current += self.unlexer.E()
        return current
    PRIVATE.min_depth = 1

    @depthcontrol
    def POWER(self):
        current = self.create_node(UnlexerRule(name='POWER'))
        current += self.unlexer.P()
        current += self.unlexer.O()
        current += self.unlexer.W()
        current += self.unlexer.E()
        current += self.unlexer.R()
        return current
    POWER.min_depth = 1

    @depthcontrol
    def PLUS(self):
        current = self.create_node(UnlexerRule(name='PLUS'))
        current += self.create_node(UnlexerRule(src='+'))
        return current
    PLUS.min_depth = 0

    @depthcontrol
    def PORT(self):
        current = self.create_node(UnlexerRule(name='PORT'))
        current += self.unlexer.P()
        current += self.unlexer.O()
        current += self.unlexer.R()
        current += self.unlexer.T()
        return current
    PORT.min_depth = 1

    @depthcontrol
    def PORTS(self):
        current = self.create_node(UnlexerRule(name='PORTS'))
        current += self.unlexer.P()
        current += self.unlexer.O()
        current += self.unlexer.R()
        current += self.unlexer.T()
        current += self.unlexer.S()
        return current
    PORTS.min_depth = 1

    @depthcontrol
    def PROPERTY(self):
        current = self.create_node(UnlexerRule(name='PROPERTY'))
        current += self.unlexer.P()
        current += self.unlexer.R()
        current += self.unlexer.O()
        current += self.unlexer.P()
        current += self.unlexer.E()
        current += self.unlexer.R()
        current += self.unlexer.T()
        current += self.unlexer.Y()
        return current
    PROPERTY.min_depth = 1

    @depthcontrol
    def PROPERTIES(self):
        current = self.create_node(UnlexerRule(name='PROPERTIES'))
        current += self.unlexer.P()
        current += self.unlexer.R()
        current += self.unlexer.O()
        current += self.unlexer.P()
        current += self.unlexer.E()
        current += self.unlexer.R()
        current += self.unlexer.T()
        current += self.unlexer.I()
        current += self.unlexer.E()
        current += self.unlexer.S()
        return current
    PROPERTIES.min_depth = 1

    @depthcontrol
    def PROPBEGIN(self):
        current = self.create_node(UnlexerRule(name='PROPBEGIN'))
        current += self.create_node(UnlexerRule(src='<<'))
        return current
    PROPBEGIN.min_depth = 0

    @depthcontrol
    def PROPEND(self):
        current = self.create_node(UnlexerRule(name='PROPEND'))
        current += self.create_node(UnlexerRule(src='>>'))
        return current
    PROPEND.min_depth = 0

    @depthcontrol
    def RECORD(self):
        current = self.create_node(UnlexerRule(name='RECORD'))
        current += self.unlexer.R()
        current += self.unlexer.E()
        current += self.unlexer.C()
        current += self.unlexer.O()
        current += self.unlexer.R()
        current += self.unlexer.D()
        return current
    RECORD.min_depth = 1

    @depthcontrol
    def REPRESENTATION(self):
        current = self.create_node(UnlexerRule(name='REPRESENTATION'))
        current += self.unlexer.R()
        current += self.unlexer.E()
        current += self.unlexer.P()
        current += self.unlexer.R()
        current += self.unlexer.E()
        current += self.unlexer.S()
        current += self.unlexer.E()
        current += self.unlexer.N()
        current += self.unlexer.T()
        current += self.unlexer.A()
        current += self.unlexer.T()
        current += self.unlexer.I()
        current += self.unlexer.O()
        current += self.unlexer.N()
        return current
    REPRESENTATION.min_depth = 1

    @depthcontrol
    def REM(self):
        current = self.create_node(UnlexerRule(name='REM'))
        current += self.create_node(UnlexerRule(src='%'))
        return current
    REM.min_depth = 0

    @depthcontrol
    def REPRESENTATIONS(self):
        current = self.create_node(UnlexerRule(name='REPRESENTATIONS'))
        current += self.unlexer.R()
        current += self.unlexer.E()
        current += self.unlexer.P()
        current += self.unlexer.R()
        current += self.unlexer.E()
        current += self.unlexer.S()
        current += self.unlexer.E()
        current += self.unlexer.N()
        current += self.unlexer.T()
        current += self.unlexer.A()
        current += self.unlexer.T()
        current += self.unlexer.I()
        current += self.unlexer.O()
        current += self.unlexer.N()
        current += self.unlexer.S()
        return current
    REPRESENTATIONS.min_depth = 1

    @depthcontrol
    def ROLE(self):
        current = self.create_node(UnlexerRule(name='ROLE'))
        current += self.unlexer.R()
        current += self.unlexer.O()
        current += self.unlexer.L()
        current += self.unlexer.E()
        return current
    ROLE.min_depth = 1

    @depthcontrol
    def RULE(self):
        current = self.create_node(UnlexerRule(name='RULE'))
        current += self.unlexer.R()
        current += self.unlexer.U()
        current += self.unlexer.L()
        current += self.unlexer.E()
        return current
    RULE.min_depth = 1

    @depthcontrol
    def ROLES(self):
        current = self.create_node(UnlexerRule(name='ROLES'))
        current += self.unlexer.R()
        current += self.unlexer.O()
        current += self.unlexer.L()
        current += self.unlexer.E()
        current += self.unlexer.S()
        return current
    ROLES.min_depth = 1

    @depthcontrol
    def SEQUENCE(self):
        current = self.create_node(UnlexerRule(name='SEQUENCE'))
        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_47', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_47', choice)] = self.unlexer.weights.get(('alt_47', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.S()
            current += self.unlexer.E()
            current += self.unlexer.Q()
            current += self.unlexer.U()
            current += self.unlexer.E()
            current += self.unlexer.N()
            current += self.unlexer.C()
            current += self.unlexer.E()
        elif choice == 1:
            current += self.unlexer.S()
            current += self.unlexer.E()
            current += self.unlexer.Q()
        return current
    SEQUENCE.min_depth = 1

    @depthcontrol
    def SELECT(self):
        current = self.create_node(UnlexerRule(name='SELECT'))
        current += self.unlexer.S()
        current += self.unlexer.E()
        current += self.unlexer.L()
        current += self.unlexer.E()
        current += self.unlexer.C()
        current += self.unlexer.T()
        return current
    SELECT.min_depth = 1

    @depthcontrol
    def SEMICOLON(self):
        current = self.create_node(UnlexerRule(name='SEMICOLON'))
        current += self.create_node(UnlexerRule(src=';'))
        return current
    SEMICOLON.min_depth = 0

    @depthcontrol
    def SET(self):
        current = self.create_node(UnlexerRule(name='SET'))
        current += self.unlexer.S()
        current += self.unlexer.E()
        current += self.unlexer.T()
        return current
    SET.min_depth = 1

    @depthcontrol
    def SET_DECLARE(self):
        current = self.create_node(UnlexerRule(name='SET_DECLARE'))
        current += self.create_node(UnlexerRule(src=':!'))
        return current
    SET_DECLARE.min_depth = 0

    @depthcontrol
    def SLASH(self):
        current = self.create_node(UnlexerRule(name='SLASH'))
        current += self.create_node(UnlexerRule(src='/'))
        return current
    SLASH.min_depth = 0

    @depthcontrol
    def STAR(self):
        current = self.create_node(UnlexerRule(name='STAR'))
        current += self.create_node(UnlexerRule(src='*'))
        return current
    STAR.min_depth = 0

    @depthcontrol
    def STRING(self):
        current = self.create_node(UnlexerRule(name='STRING'))
        current += self.unlexer.S()
        current += self.unlexer.T()
        current += self.unlexer.R()
        current += self.unlexer.I()
        current += self.unlexer.N()
        current += self.unlexer.G()
        return current
    STRING.min_depth = 1

    @depthcontrol
    def STYLE(self):
        current = self.create_node(UnlexerRule(name='STYLE'))
        current += self.unlexer.S()
        current += self.unlexer.T()
        current += self.unlexer.Y()
        current += self.unlexer.L()
        current += self.unlexer.E()
        return current
    STYLE.min_depth = 1

    @depthcontrol
    def SYSTEM(self):
        current = self.create_node(UnlexerRule(name='SYSTEM'))
        current += self.unlexer.S()
        current += self.unlexer.Y()
        current += self.unlexer.S()
        current += self.unlexer.T()
        current += self.unlexer.E()
        current += self.unlexer.M()
        return current
    SYSTEM.min_depth = 1

    @depthcontrol
    def TO(self):
        current = self.create_node(UnlexerRule(name='TO'))
        current += self.unlexer.T()
        current += self.unlexer.O()
        return current
    TO.min_depth = 1

    @depthcontrol
    def TYPE(self):
        current = self.create_node(UnlexerRule(name='TYPE'))
        current += self.unlexer.T()
        current += self.unlexer.Y()
        current += self.unlexer.P()
        current += self.unlexer.E()
        return current
    TYPE.min_depth = 1

    @depthcontrol
    def UNIQUE(self):
        current = self.create_node(UnlexerRule(name='UNIQUE'))
        current += self.unlexer.U()
        current += self.unlexer.N()
        current += self.unlexer.I()
        current += self.unlexer.Q()
        current += self.unlexer.U()
        current += self.unlexer.E()
        return current
    UNIQUE.min_depth = 1

    @depthcontrol
    def WITH(self):
        current = self.create_node(UnlexerRule(name='WITH'))
        current += self.unlexer.W()
        current += self.unlexer.I()
        current += self.unlexer.T()
        current += self.unlexer.H()
        return current
    WITH.min_depth = 1

    @depthcontrol
    def VIEW(self):
        current = self.create_node(UnlexerRule(name='VIEW'))
        current += self.unlexer.V()
        current += self.unlexer.I()
        current += self.unlexer.E()
        current += self.unlexer.W()
        return current
    VIEW.min_depth = 1

    @depthcontrol
    def BIT_OR(self):
        current = self.create_node(UnlexerRule(name='BIT_OR'))
        current += self.create_node(UnlexerRule(src='|'))
        return current
    BIT_OR.min_depth = 0

    @depthcontrol
    def TRUE(self):
        current = self.create_node(UnlexerRule(name='TRUE'))
        current += self.unlexer.T()
        current += self.unlexer.R()
        current += self.unlexer.U()
        current += self.unlexer.E()
        return current
    TRUE.min_depth = 1

    @depthcontrol
    def FALSE(self):
        current = self.create_node(UnlexerRule(name='FALSE'))
        current += self.unlexer.F()
        current += self.unlexer.A()
        current += self.unlexer.L()
        current += self.unlexer.S()
        current += self.unlexer.E()
        return current
    FALSE.min_depth = 1

    @depthcontrol
    def A(self):
        current = self.create_node(UnlexerRule(name='A'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_55', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_55', choice)] = self.unlexer.weights.get(('alt_55', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='a'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='A'))
        return current
    A.min_depth = 0

    @depthcontrol
    def B(self):
        current = self.create_node(UnlexerRule(name='B'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_60', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_60', choice)] = self.unlexer.weights.get(('alt_60', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='b'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='B'))
        return current
    B.min_depth = 0

    @depthcontrol
    def C(self):
        current = self.create_node(UnlexerRule(name='C'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_65', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_65', choice)] = self.unlexer.weights.get(('alt_65', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='c'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='C'))
        return current
    C.min_depth = 0

    @depthcontrol
    def D(self):
        current = self.create_node(UnlexerRule(name='D'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_70', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_70', choice)] = self.unlexer.weights.get(('alt_70', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='d'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='D'))
        return current
    D.min_depth = 0

    @depthcontrol
    def E(self):
        current = self.create_node(UnlexerRule(name='E'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_75', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_75', choice)] = self.unlexer.weights.get(('alt_75', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='e'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='E'))
        return current
    E.min_depth = 0

    @depthcontrol
    def F(self):
        current = self.create_node(UnlexerRule(name='F'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_80', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_80', choice)] = self.unlexer.weights.get(('alt_80', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='f'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='F'))
        return current
    F.min_depth = 0

    @depthcontrol
    def G(self):
        current = self.create_node(UnlexerRule(name='G'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_85', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_85', choice)] = self.unlexer.weights.get(('alt_85', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='g'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='G'))
        return current
    G.min_depth = 0

    @depthcontrol
    def H(self):
        current = self.create_node(UnlexerRule(name='H'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_90', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_90', choice)] = self.unlexer.weights.get(('alt_90', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='h'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='H'))
        return current
    H.min_depth = 0

    @depthcontrol
    def I(self):
        current = self.create_node(UnlexerRule(name='I'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_95', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_95', choice)] = self.unlexer.weights.get(('alt_95', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='i'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='I'))
        return current
    I.min_depth = 0

    @depthcontrol
    def J(self):
        current = self.create_node(UnlexerRule(name='J'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_100', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_100', choice)] = self.unlexer.weights.get(('alt_100', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='j'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='J'))
        return current
    J.min_depth = 0

    @depthcontrol
    def K(self):
        current = self.create_node(UnlexerRule(name='K'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_105', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_105', choice)] = self.unlexer.weights.get(('alt_105', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='k'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='K'))
        return current
    K.min_depth = 0

    @depthcontrol
    def L(self):
        current = self.create_node(UnlexerRule(name='L'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_110', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_110', choice)] = self.unlexer.weights.get(('alt_110', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='l'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='L'))
        return current
    L.min_depth = 0

    @depthcontrol
    def M(self):
        current = self.create_node(UnlexerRule(name='M'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_115', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_115', choice)] = self.unlexer.weights.get(('alt_115', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='m'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='M'))
        return current
    M.min_depth = 0

    @depthcontrol
    def N(self):
        current = self.create_node(UnlexerRule(name='N'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_120', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_120', choice)] = self.unlexer.weights.get(('alt_120', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='n'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='N'))
        return current
    N.min_depth = 0

    @depthcontrol
    def O(self):
        current = self.create_node(UnlexerRule(name='O'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_125', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_125', choice)] = self.unlexer.weights.get(('alt_125', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='o'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='O'))
        return current
    O.min_depth = 0

    @depthcontrol
    def P(self):
        current = self.create_node(UnlexerRule(name='P'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_130', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_130', choice)] = self.unlexer.weights.get(('alt_130', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='p'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='P'))
        return current
    P.min_depth = 0

    @depthcontrol
    def Q(self):
        current = self.create_node(UnlexerRule(name='Q'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_135', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_135', choice)] = self.unlexer.weights.get(('alt_135', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='q'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='Q'))
        return current
    Q.min_depth = 0

    @depthcontrol
    def R(self):
        current = self.create_node(UnlexerRule(name='R'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_140', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_140', choice)] = self.unlexer.weights.get(('alt_140', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='r'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='R'))
        return current
    R.min_depth = 0

    @depthcontrol
    def S(self):
        current = self.create_node(UnlexerRule(name='S'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_145', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_145', choice)] = self.unlexer.weights.get(('alt_145', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='s'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='S'))
        return current
    S.min_depth = 0

    @depthcontrol
    def T(self):
        current = self.create_node(UnlexerRule(name='T'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_150', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_150', choice)] = self.unlexer.weights.get(('alt_150', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='t'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='T'))
        return current
    T.min_depth = 0

    @depthcontrol
    def U(self):
        current = self.create_node(UnlexerRule(name='U'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_155', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_155', choice)] = self.unlexer.weights.get(('alt_155', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='u'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='U'))
        return current
    U.min_depth = 0

    @depthcontrol
    def V(self):
        current = self.create_node(UnlexerRule(name='V'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_160', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_160', choice)] = self.unlexer.weights.get(('alt_160', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='v'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='V'))
        return current
    V.min_depth = 0

    @depthcontrol
    def W(self):
        current = self.create_node(UnlexerRule(name='W'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_165', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_165', choice)] = self.unlexer.weights.get(('alt_165', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='w'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='W'))
        return current
    W.min_depth = 0

    @depthcontrol
    def X(self):
        current = self.create_node(UnlexerRule(name='X'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_170', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_170', choice)] = self.unlexer.weights.get(('alt_170', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='x'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='X'))
        return current
    X.min_depth = 0

    @depthcontrol
    def Y(self):
        current = self.create_node(UnlexerRule(name='Y'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_175', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_175', choice)] = self.unlexer.weights.get(('alt_175', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='y'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='Y'))
        return current
    Y.min_depth = 0

    @depthcontrol
    def Z(self):
        current = self.create_node(UnlexerRule(name='Z'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_180', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_180', choice)] = self.unlexer.weights.get(('alt_180', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='z'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='Z'))
        return current
    Z.min_depth = 0

    @depthcontrol
    def BOOLEAN(self):
        current = self.create_node(UnlexerRule(name='BOOLEAN'))
        choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_185', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_185', choice)] = self.unlexer.weights.get(('alt_185', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.TRUE()
        elif choice == 1:
            current += self.unlexer.FALSE()
        return current
    BOOLEAN.min_depth = 2

    @depthcontrol
    def FLOATING_POINT_LITERAL(self):
        current = self.create_node(UnlexerRule(name='FLOATING_POINT_LITERAL'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_189', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_189', choice)] = self.unlexer.weights.get(('alt_189', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.create_node(UnlexerRule(src='-'))
                elif choice == 1:
                    current += self.create_node(UnlexerRule(src='+'))

        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.create_node(UnlexerRule(src=self.char_from_list(charset_0)))

        current += self.create_node(UnlexerRule(src='.'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.create_node(UnlexerRule(src=self.char_from_list(charset_1)))

        return current
    FLOATING_POINT_LITERAL.min_depth = 0

    @depthcontrol
    def INTEGER_LITERAL(self):
        current = self.create_node(UnlexerRule(name='INTEGER_LITERAL'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.create_node(UnlexerRule(src=self.char_from_list(charset_2)))

        return current
    INTEGER_LITERAL.min_depth = 0

    @depthcontrol
    def STRING_LITERAL(self):
        current = self.create_node(UnlexerRule(name='STRING_LITERAL'))
        current += self.create_node(UnlexerRule(src='"'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += UnlexerRule(src=self.any_char())

        current += self.create_node(UnlexerRule(src='"'))
        return current
    STRING_LITERAL.min_depth = 0

    @depthcontrol
    def IDENTIFIER(self):
        current = self.create_node(UnlexerRule(name='IDENTIFIER'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_3)))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=self.char_from_list(charset_4)))

        return current
    IDENTIFIER.min_depth = 0

    @depthcontrol
    def LINE_COMMENT(self):
        current = self.create_node(UnlexerRule(name='LINE_COMMENT'))
        current += self.create_node(UnlexerRule(src='//'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += UnlexerRule(src=self.char_from_list(charset_5))

        return current
    LINE_COMMENT.min_depth = 0

    @depthcontrol
    def BLOCK_COMMENT(self):
        current = self.create_node(UnlexerRule(name='BLOCK_COMMENT'))
        current += self.create_node(UnlexerRule(src='/*'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += UnlexerRule(src=self.any_char())

        current += self.create_node(UnlexerRule(src='*/'))
        return current
    BLOCK_COMMENT.min_depth = 0

    @depthcontrol
    def WS(self):
        current = self.create_node(UnlexerRule(name='WS'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.create_node(UnlexerRule(src=self.char_from_list(charset_6)))

        return current
    WS.min_depth = 0


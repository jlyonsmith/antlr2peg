# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

import acmeUnlexer


class acmeUnparser(Grammarinator):

    def __init__(self, unlexer):
        super(acmeUnparser, self).__init__()
        self.unlexer = unlexer
    @depthcontrol
    def acmeCompUnit(self):
        current = self.create_node(UnparserRule(name='acmeCompUnit'))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.acmeImportDeclaration()

        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                choice = self.choice([0 if [3, 3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_205', i), 1) for i, w in enumerate([1, 1, 1])])
                self.unlexer.weights[('alt_205', choice)] = self.unlexer.weights.get(('alt_205', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.acmeSystemDeclaration()
                elif choice == 1:
                    current += self.acmeFamilyDeclaration()
                elif choice == 2:
                    current += self.acmeDesignDeclaration()

        current += self.unlexer.EOF()
        return current
    acmeCompUnit.min_depth = 3

    @depthcontrol
    def acmeImportDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeImportDeclaration'))
        current += self.unlexer.IMPORT()
        choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_209', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_209', choice)] = self.unlexer.weights.get(('alt_209', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.filename()
        elif choice == 1:
            current += self.stringLiteral()
        current += self.unlexer.SEMICOLON()
        return current
    acmeImportDeclaration.min_depth = 2

    @depthcontrol
    def stringLiteral(self):
        current = self.create_node(UnparserRule(name='stringLiteral'))
        current += self.unlexer.STRING_LITERAL()
        return current
    stringLiteral.min_depth = 1

    @depthcontrol
    def filename(self):
        current = self.create_node(UnparserRule(name='filename'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_213', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_213', choice)] = self.unlexer.weights.get(('alt_213', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.create_node(UnlexerRule(src='$'))
                elif choice == 1:
                    current += self.create_node(UnlexerRule(src='%'))

        current += self.unlexer.IDENTIFIER()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                if self.unlexer.max_depth >= 0:
                    for _ in self.one_or_more():
                        choice = self.choice([0 if [0, 0, 0, 0, 0, 0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_219', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
                        self.unlexer.weights[('alt_219', choice)] = self.unlexer.weights.get(('alt_219', choice), 1) * self.unlexer.cooldown
                        if choice == 0:
                            current += self.create_node(UnlexerRule(src='.'))
                        elif choice == 1:
                            current += self.create_node(UnlexerRule(src=':'))
                        elif choice == 2:
                            current += self.create_node(UnlexerRule(src='-'))
                        elif choice == 3:
                            current += self.create_node(UnlexerRule(src='+'))
                        elif choice == 4:
                            current += self.create_node(UnlexerRule(src='\\'))
                        elif choice == 5:
                            current += self.create_node(UnlexerRule(src='\\\\'))
                        elif choice == 6:
                            current += self.create_node(UnlexerRule(src='/'))
                        elif choice == 7:
                            current += self.create_node(UnlexerRule(src='$'))
                        elif choice == 8:
                            current += self.create_node(UnlexerRule(src='%'))

                current += self.unlexer.IDENTIFIER()

        return current
    filename.min_depth = 1

    @depthcontrol
    def identifier(self):
        current = self.create_node(UnparserRule(name='identifier'))
        current += self.unlexer.IDENTIFIER()
        return current
    identifier.min_depth = 1

    @depthcontrol
    def codeLiteral(self):
        current = self.create_node(UnparserRule(name='codeLiteral'))
        current += self.unlexer.STRING_LITERAL()
        return current
    codeLiteral.min_depth = 1

    @depthcontrol
    def acmeFamilyDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeFamilyDeclaration'))
        choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_238', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_238', choice)] = self.unlexer.weights.get(('alt_238', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.FAMILY()
        elif choice == 1:
            current += self.unlexer.STYLE()
        current += self.identifier()
        choice = self.choice([0 if [1, 2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_241', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_241', choice)] = self.unlexer.weights.get(('alt_241', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SEMICOLON()
        elif choice == 1:
            current += self.unlexer.ASSIGN()
            current += self.acmeFamilyBody()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.unlexer.SEMICOLON()

        elif choice == 2:
            current += self.unlexer.EXTENDS()
            current += self.acmeFamilyRef()
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_more():
                    current += self.unlexer.COMMA()
                    current += self.acmeFamilyRef()

            choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_247', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_247', choice)] = self.unlexer.weights.get(('alt_247', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.unlexer.SEMICOLON()
            elif choice == 1:
                current += self.unlexer.WITH()
                current += self.acmeFamilyBody()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.SEMICOLON()

        return current
    acmeFamilyDeclaration.min_depth = 2

    @depthcontrol
    def acmeFamilyBody(self):
        current = self.create_node(UnparserRule(name='acmeFamilyBody'))
        current += self.unlexer.LBRACE()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [3, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_252', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_252', choice)] = self.unlexer.weights.get(('alt_252', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    if self.unlexer.max_depth >= 2:
                        for _ in self.zero_or_one():
                            choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_256', i), 1) for i, w in enumerate([1, 1])])
                            self.unlexer.weights[('alt_256', choice)] = self.unlexer.weights.get(('alt_256', choice), 1) * self.unlexer.cooldown
                            if choice == 0:
                                current += self.unlexer.PUBLIC()
                            elif choice == 1:
                                current += self.unlexer.PRIVATE()

                    if self.unlexer.max_depth >= 2:
                        for _ in self.zero_or_one():
                            choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_260', i), 1) for i, w in enumerate([1, 1])])
                            self.unlexer.weights[('alt_260', choice)] = self.unlexer.weights.get(('alt_260', choice), 1) * self.unlexer.cooldown
                            if choice == 0:
                                current += self.unlexer.FINAL()
                            elif choice == 1:
                                current += self.unlexer.ABSTRACT()

                    choice = self.choice([0 if [3, 3, 3, 3, 3, 3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_263', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
                    self.unlexer.weights[('alt_263', choice)] = self.unlexer.weights.get(('alt_263', choice), 1) * self.unlexer.cooldown
                    if choice == 0:
                        current += self.acmePortTypeDeclaration()
                    elif choice == 1:
                        current += self.acmeRoleTypeDeclaration()
                    elif choice == 2:
                        current += self.acmeComponentTypeDeclaration()
                    elif choice == 3:
                        current += self.acmeConnectorTypeDeclaration()
                    elif choice == 4:
                        current += self.acmeGenericElementTypeDeclaration()
                    elif choice == 5:
                        current += self.acmePropertyTypeDeclaration()
                    elif choice == 6:
                        current += self.acmeGroupTypeDeclaration()
                elif choice == 1:
                    choice = self.choice([0 if [4, 2, 3, 3, 3, 3, 3, 3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_271', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
                    self.unlexer.weights[('alt_271', choice)] = self.unlexer.weights.get(('alt_271', choice), 1) * self.unlexer.cooldown
                    if choice == 0:
                        current += self.acmeDesignAnalysisDeclaration()
                    elif choice == 1:
                        current += self.designRule()
                    elif choice == 2:
                        current += self.acmePortDeclaration()
                    elif choice == 3:
                        current += self.acmeRoleDeclaration()
                    elif choice == 4:
                        current += self.acmeComponentDeclaration()
                    elif choice == 5:
                        current += self.acmeConnectorDeclaration()
                    elif choice == 6:
                        current += self.acmePropertyDeclaration()
                    elif choice == 7:
                        current += self.acmeGroupDeclaration()
                    elif choice == 8:
                        current += self.acmeAttachmentDeclaration()

        current += self.unlexer.RBRACE()
        return current
    acmeFamilyBody.min_depth = 1

    @depthcontrol
    def acmeSystemDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeSystemDeclaration'))
        current += self.unlexer.SYSTEM()
        current += self.identifier()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.COLON()
                current += self.acmeFamilyRef()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmeFamilyRef()


        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_283', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_283', choice)] = self.unlexer.weights.get(('alt_283', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SEMICOLON()
        elif choice == 1:
            current += self.unlexer.ASSIGN()
            choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_286', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_286', choice)] = self.unlexer.weights.get(('alt_286', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.acmeSystemBody()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.SEMICOLON()

            elif choice == 1:
                current += self.unlexer.NEW()
                current += self.acmeFamilyInstantiationRef()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmeFamilyInstantiationRef()

                choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_291', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_291', choice)] = self.unlexer.weights.get(('alt_291', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.SEMICOLON()
                elif choice == 1:
                    current += self.unlexer.EXTENDED()
                    current += self.unlexer.WITH()
                    current += self.acmeSystemBody()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_one():
                            current += self.unlexer.SEMICOLON()

        return current
    acmeSystemDeclaration.min_depth = 2

    @depthcontrol
    def acmeSystemBody(self):
        current = self.create_node(UnparserRule(name='acmeSystemBody'))
        current += self.unlexer.LBRACE()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [3, 3, 3, 3, 3, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_296', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1])])
                self.unlexer.weights[('alt_296', choice)] = self.unlexer.weights.get(('alt_296', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.acmePropertyDeclaration()
                elif choice == 1:
                    current += self.acmeComponentDeclaration()
                elif choice == 2:
                    current += self.acmeConnectorDeclaration()
                elif choice == 3:
                    current += self.acmeAttachmentDeclaration()
                elif choice == 4:
                    current += self.acmeGroupDeclaration()
                elif choice == 5:
                    current += self.designRule()

        current += self.unlexer.RBRACE()
        return current
    acmeSystemBody.min_depth = 1

    @depthcontrol
    def acmeDesignDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeDesignDeclaration'))
        current += self.unlexer.DESIGN()
        return current
    acmeDesignDeclaration.min_depth = 2

    @depthcontrol
    def acmeComponentTypeRef(self):
        current = self.create_node(UnparserRule(name='acmeComponentTypeRef'))
        current += self.identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.DOT()
                current += self.identifier()

        return current
    acmeComponentTypeRef.min_depth = 2

    @depthcontrol
    def acmeComponentInstantiatedTypeRef(self):
        current = self.create_node(UnparserRule(name='acmeComponentInstantiatedTypeRef'))
        current += self.identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.DOT()
                current += self.identifier()

        return current
    acmeComponentInstantiatedTypeRef.min_depth = 2

    @depthcontrol
    def acmeConnectorTypeRef(self):
        current = self.create_node(UnparserRule(name='acmeConnectorTypeRef'))
        current += self.identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.DOT()
                current += self.identifier()

        return current
    acmeConnectorTypeRef.min_depth = 2

    @depthcontrol
    def acmeConnectorInstantiatedTypeRef(self):
        current = self.create_node(UnparserRule(name='acmeConnectorInstantiatedTypeRef'))
        current += self.identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.DOT()
                current += self.identifier()

        return current
    acmeConnectorInstantiatedTypeRef.min_depth = 2

    @depthcontrol
    def acmePortTypeRef(self):
        current = self.create_node(UnparserRule(name='acmePortTypeRef'))
        current += self.identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.DOT()
                current += self.identifier()

        return current
    acmePortTypeRef.min_depth = 2

    @depthcontrol
    def acmePortInstantiatedTypeRef(self):
        current = self.create_node(UnparserRule(name='acmePortInstantiatedTypeRef'))
        current += self.identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.DOT()
                current += self.identifier()

        return current
    acmePortInstantiatedTypeRef.min_depth = 2

    @depthcontrol
    def acmeGroupTypeRef(self):
        current = self.create_node(UnparserRule(name='acmeGroupTypeRef'))
        current += self.identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.DOT()
                current += self.identifier()

        return current
    acmeGroupTypeRef.min_depth = 2

    @depthcontrol
    def acmeGroupInstantiatedTypeRef(self):
        current = self.create_node(UnparserRule(name='acmeGroupInstantiatedTypeRef'))
        current += self.identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.DOT()
                current += self.identifier()

        return current
    acmeGroupInstantiatedTypeRef.min_depth = 2

    @depthcontrol
    def acmeRoleTypeRef(self):
        current = self.create_node(UnparserRule(name='acmeRoleTypeRef'))
        current += self.identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.DOT()
                current += self.identifier()

        return current
    acmeRoleTypeRef.min_depth = 2

    @depthcontrol
    def acmeRoleInstantiatedTypeRef(self):
        current = self.create_node(UnparserRule(name='acmeRoleInstantiatedTypeRef'))
        current += self.identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.DOT()
                current += self.identifier()

        return current
    acmeRoleInstantiatedTypeRef.min_depth = 2

    @depthcontrol
    def acmeViewTypeRef(self):
        current = self.create_node(UnparserRule(name='acmeViewTypeRef'))
        current += self.identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.DOT()
                current += self.identifier()

        return current
    acmeViewTypeRef.min_depth = 2

    @depthcontrol
    def acmeViewInstantiatedTypeRef(self):
        current = self.create_node(UnparserRule(name='acmeViewInstantiatedTypeRef'))
        current += self.identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.DOT()
                current += self.identifier()

        return current
    acmeViewInstantiatedTypeRef.min_depth = 2

    @depthcontrol
    def acmeFamilyRef(self):
        current = self.create_node(UnparserRule(name='acmeFamilyRef'))
        current += self.identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.DOT()
                current += self.identifier()

        return current
    acmeFamilyRef.min_depth = 2

    @depthcontrol
    def acmeFamilyInstantiationRef(self):
        current = self.create_node(UnparserRule(name='acmeFamilyInstantiationRef'))
        current += self.identifier()
        return current
    acmeFamilyInstantiationRef.min_depth = 2

    @depthcontrol
    def acmeElementTypeRef(self):
        current = self.create_node(UnparserRule(name='acmeElementTypeRef'))
        current += self.identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.DOT()
                current += self.identifier()

        return current
    acmeElementTypeRef.min_depth = 2

    @depthcontrol
    def acmePropertyTypeDeclarationRef(self):
        current = self.create_node(UnparserRule(name='acmePropertyTypeDeclarationRef'))
        current += self.identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.DOT()
                current += self.identifier()

        return current
    acmePropertyTypeDeclarationRef.min_depth = 2

    @depthcontrol
    def acmeInstanceRef(self):
        current = self.create_node(UnparserRule(name='acmeInstanceRef'))
        current += self.unlexer.IDENTIFIER()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                current += self.unlexer.DOT()
                current += self.unlexer.IDENTIFIER()

        return current
    acmeInstanceRef.min_depth = 1

    @depthcontrol
    def acmeGenericElementTypeDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeGenericElementTypeDeclaration'))
        current += self.unlexer.ELEMENT()
        current += self.unlexer.TYPE()
        current += self.identifier()
        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_319', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_319', choice)] = self.unlexer.weights.get(('alt_319', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SEMICOLON()
        elif choice == 1:
            choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_322', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_322', choice)] = self.unlexer.weights.get(('alt_322', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.unlexer.ASSIGN()
                current += self.acmeGenericElementBody()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.SEMICOLON()

            elif choice == 1:
                current += self.unlexer.EXTENDS()
                current += self.acmeElementTypeRef()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmeElementTypeRef()

                choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_327', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_327', choice)] = self.unlexer.weights.get(('alt_327', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.SEMICOLON()
                elif choice == 1:
                    current += self.unlexer.WITH()
                    current += self.acmeGenericElementBody()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_one():
                            current += self.unlexer.SEMICOLON()

        return current
    acmeGenericElementTypeDeclaration.min_depth = 2

    @depthcontrol
    def acmeGenericElementBody(self):
        current = self.create_node(UnparserRule(name='acmeGenericElementBody'))
        current += self.unlexer.LBRACE()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [3, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_332', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_332', choice)] = self.unlexer.weights.get(('alt_332', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.acmePropertyDeclaration()
                elif choice == 1:
                    current += self.designRule()

        current += self.unlexer.RBRACE()
        return current
    acmeGenericElementBody.min_depth = 1

    @depthcontrol
    def acmeGroupTypeDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeGroupTypeDeclaration'))
        current += self.unlexer.GROUP()
        current += self.unlexer.TYPE()
        current += self.identifier()
        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_335', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_335', choice)] = self.unlexer.weights.get(('alt_335', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SEMICOLON()
        elif choice == 1:
            choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_338', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_338', choice)] = self.unlexer.weights.get(('alt_338', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.unlexer.ASSIGN()
                current += self.acmeGroupBody()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.SEMICOLON()

            elif choice == 1:
                current += self.unlexer.EXTENDS()
                current += self.acmeGroupTypeRef()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmeGroupTypeRef()

                choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_343', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_343', choice)] = self.unlexer.weights.get(('alt_343', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.SEMICOLON()
                elif choice == 1:
                    current += self.unlexer.WITH()
                    current += self.acmeGroupBody()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_one():
                            current += self.unlexer.SEMICOLON()

        return current
    acmeGroupTypeDeclaration.min_depth = 2

    @depthcontrol
    def acmeGroupDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeGroupDeclaration'))
        current += self.unlexer.GROUP()
        current += self.identifier()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.COLON()
                current += self.acmeGroupTypeRef()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmeGroupTypeRef()


        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_349', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_349', choice)] = self.unlexer.weights.get(('alt_349', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SEMICOLON()
        elif choice == 1:
            current += self.unlexer.ASSIGN()
            choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_352', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_352', choice)] = self.unlexer.weights.get(('alt_352', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.acmeGroupBody()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.SEMICOLON()

            elif choice == 1:
                current += self.unlexer.NEW()
                current += self.acmeGroupInstantiatedTypeRef()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmeGroupInstantiatedTypeRef()

                choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_357', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_357', choice)] = self.unlexer.weights.get(('alt_357', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.SEMICOLON()
                elif choice == 1:
                    current += self.unlexer.EXTENDED()
                    current += self.unlexer.WITH()
                    current += self.acmeGroupBody()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_one():
                            current += self.unlexer.SEMICOLON()

        return current
    acmeGroupDeclaration.min_depth = 2

    @depthcontrol
    def acmeGroupBody(self):
        current = self.create_node(UnparserRule(name='acmeGroupBody'))
        current += self.unlexer.LBRACE()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [3, 3, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_362', i), 1) for i, w in enumerate([1, 1, 1])])
                self.unlexer.weights[('alt_362', choice)] = self.unlexer.weights.get(('alt_362', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.acmeMembersBlock()
                elif choice == 1:
                    current += self.acmePropertyDeclaration()
                elif choice == 2:
                    current += self.designRule()

        current += self.unlexer.RBRACE()
        return current
    acmeGroupBody.min_depth = 1

    @depthcontrol
    def acmeMembersBlock(self):
        current = self.create_node(UnparserRule(name='acmeMembersBlock'))
        current += self.unlexer.MEMBERS()
        current += self.unlexer.LBRACE()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.acmeInstanceRef()
                if self.unlexer.max_depth >= 2:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmeInstanceRef()


        current += self.unlexer.RBRACE()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.SEMICOLON()

        return current
    acmeMembersBlock.min_depth = 2

    @depthcontrol
    def acmePortTypeDeclaration(self):
        current = self.create_node(UnparserRule(name='acmePortTypeDeclaration'))
        current += self.unlexer.PORT()
        current += self.unlexer.TYPE()
        current += self.identifier()
        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_369', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_369', choice)] = self.unlexer.weights.get(('alt_369', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SEMICOLON()
        elif choice == 1:
            choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_372', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_372', choice)] = self.unlexer.weights.get(('alt_372', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.unlexer.ASSIGN()
                current += self.acmePortBody()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.SEMICOLON()

            elif choice == 1:
                current += self.unlexer.EXTENDS()
                current += self.acmePortTypeRef()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmePortTypeRef()

                choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_377', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_377', choice)] = self.unlexer.weights.get(('alt_377', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.SEMICOLON()
                elif choice == 1:
                    current += self.unlexer.WITH()
                    current += self.acmePortBody()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_one():
                            current += self.unlexer.SEMICOLON()

        return current
    acmePortTypeDeclaration.min_depth = 2

    @depthcontrol
    def acmePortDeclaration(self):
        current = self.create_node(UnparserRule(name='acmePortDeclaration'))
        current += self.unlexer.PORT()
        current += self.identifier()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.COLON()
                current += self.acmePortTypeRef()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmePortTypeRef()


        choice = self.choice([0 if [0, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_383', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_383', choice)] = self.unlexer.weights.get(('alt_383', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.unlexer.SEMICOLON()

        elif choice == 1:
            current += self.unlexer.ASSIGN()
            choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_387', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_387', choice)] = self.unlexer.weights.get(('alt_387', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.acmePortBody()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.SEMICOLON()

            elif choice == 1:
                current += self.unlexer.NEW()
                current += self.acmePortInstantiatedTypeRef()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmePortInstantiatedTypeRef()

                choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_392', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_392', choice)] = self.unlexer.weights.get(('alt_392', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.SEMICOLON()
                elif choice == 1:
                    current += self.unlexer.EXTENDED()
                    current += self.unlexer.WITH()
                    current += self.acmePortBody()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_one():
                            current += self.unlexer.SEMICOLON()

        return current
    acmePortDeclaration.min_depth = 2

    @depthcontrol
    def acmePortBody(self):
        current = self.create_node(UnparserRule(name='acmePortBody'))
        current += self.unlexer.LBRACE()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [3, 2, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_397', i), 1) for i, w in enumerate([1, 1, 1])])
                self.unlexer.weights[('alt_397', choice)] = self.unlexer.weights.get(('alt_397', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.acmePropertyDeclaration()
                elif choice == 1:
                    current += self.designRule()
                elif choice == 2:
                    current += self.acmeRepresentationDeclaration()

        current += self.unlexer.RBRACE()
        return current
    acmePortBody.min_depth = 1

    @depthcontrol
    def acmeRoleTypeDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeRoleTypeDeclaration'))
        current += self.unlexer.ROLE()
        current += self.unlexer.TYPE()
        current += self.identifier()
        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_401', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_401', choice)] = self.unlexer.weights.get(('alt_401', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SEMICOLON()
        elif choice == 1:
            choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_404', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_404', choice)] = self.unlexer.weights.get(('alt_404', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.unlexer.ASSIGN()
                current += self.acmeRoleBody()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.SEMICOLON()

            elif choice == 1:
                current += self.unlexer.EXTENDS()
                current += self.acmeRoleTypeRef()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmeRoleTypeRef()

                choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_409', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_409', choice)] = self.unlexer.weights.get(('alt_409', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.SEMICOLON()
                elif choice == 1:
                    current += self.unlexer.WITH()
                    current += self.acmeRoleBody()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_one():
                            current += self.unlexer.SEMICOLON()

        return current
    acmeRoleTypeDeclaration.min_depth = 2

    @depthcontrol
    def acmeRoleDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeRoleDeclaration'))
        current += self.unlexer.ROLE()
        current += self.identifier()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.COLON()
                current += self.acmeRoleTypeRef()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmeRoleTypeRef()


        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_415', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_415', choice)] = self.unlexer.weights.get(('alt_415', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SEMICOLON()
        elif choice == 1:
            current += self.unlexer.ASSIGN()
            choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_418', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_418', choice)] = self.unlexer.weights.get(('alt_418', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.acmeRoleBody()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.SEMICOLON()

            elif choice == 1:
                current += self.unlexer.NEW()
                current += self.acmeRoleInstantiatedTypeRef()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmeRoleInstantiatedTypeRef()

                choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_423', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_423', choice)] = self.unlexer.weights.get(('alt_423', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.SEMICOLON()
                elif choice == 1:
                    current += self.unlexer.EXTENDED()
                    current += self.unlexer.WITH()
                    current += self.acmeRoleBody()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_one():
                            current += self.unlexer.SEMICOLON()

        return current
    acmeRoleDeclaration.min_depth = 2

    @depthcontrol
    def acmeRoleBody(self):
        current = self.create_node(UnparserRule(name='acmeRoleBody'))
        current += self.unlexer.LBRACE()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [3, 2, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_428', i), 1) for i, w in enumerate([1, 1, 1])])
                self.unlexer.weights[('alt_428', choice)] = self.unlexer.weights.get(('alt_428', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.acmePropertyDeclaration()
                elif choice == 1:
                    current += self.designRule()
                elif choice == 2:
                    current += self.acmeRepresentationDeclaration()

        current += self.unlexer.RBRACE()
        return current
    acmeRoleBody.min_depth = 1

    @depthcontrol
    def acmeComponentTypeDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeComponentTypeDeclaration'))
        current += self.unlexer.COMPONENT()
        current += self.unlexer.TYPE()
        current += self.identifier()
        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_432', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_432', choice)] = self.unlexer.weights.get(('alt_432', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SEMICOLON()
        elif choice == 1:
            choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_435', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_435', choice)] = self.unlexer.weights.get(('alt_435', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.unlexer.ASSIGN()
                current += self.acmeComponentBody()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.SEMICOLON()

            elif choice == 1:
                current += self.unlexer.EXTENDS()
                current += self.acmeComponentTypeRef()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmeComponentTypeRef()

                choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_440', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_440', choice)] = self.unlexer.weights.get(('alt_440', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.SEMICOLON()
                elif choice == 1:
                    current += self.unlexer.WITH()
                    current += self.acmeComponentBody()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_one():
                            current += self.unlexer.SEMICOLON()

        return current
    acmeComponentTypeDeclaration.min_depth = 2

    @depthcontrol
    def acmeComponentDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeComponentDeclaration'))
        current += self.unlexer.COMPONENT()
        current += self.identifier()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.COLON()
                current += self.acmeComponentTypeRef()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmeComponentTypeRef()


        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_446', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_446', choice)] = self.unlexer.weights.get(('alt_446', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SEMICOLON()
        elif choice == 1:
            current += self.unlexer.ASSIGN()
            choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_449', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_449', choice)] = self.unlexer.weights.get(('alt_449', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.acmeComponentBody()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.SEMICOLON()

            elif choice == 1:
                current += self.unlexer.NEW()
                current += self.acmeComponentInstantiatedTypeRef()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmeComponentInstantiatedTypeRef()

                choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_454', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_454', choice)] = self.unlexer.weights.get(('alt_454', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.SEMICOLON()
                elif choice == 1:
                    current += self.unlexer.EXTENDED()
                    current += self.unlexer.WITH()
                    current += self.acmeComponentBody()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_one():
                            current += self.unlexer.SEMICOLON()

        return current
    acmeComponentDeclaration.min_depth = 2

    @depthcontrol
    def acmeComponentBody(self):
        current = self.create_node(UnparserRule(name='acmeComponentBody'))
        current += self.unlexer.LBRACE()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [3, 3, 2, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_459', i), 1) for i, w in enumerate([1, 1, 1, 1])])
                self.unlexer.weights[('alt_459', choice)] = self.unlexer.weights.get(('alt_459', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.acmePropertyDeclaration()
                elif choice == 1:
                    current += self.acmePortDeclaration()
                elif choice == 2:
                    current += self.designRule()
                elif choice == 3:
                    current += self.acmeRepresentationDeclaration()

        current += self.unlexer.RBRACE()
        return current
    acmeComponentBody.min_depth = 1

    @depthcontrol
    def acmeConnectorTypeDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeConnectorTypeDeclaration'))
        current += self.unlexer.CONNECTOR()
        current += self.unlexer.TYPE()
        current += self.identifier()
        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_464', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_464', choice)] = self.unlexer.weights.get(('alt_464', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SEMICOLON()
        elif choice == 1:
            choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_467', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_467', choice)] = self.unlexer.weights.get(('alt_467', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.unlexer.ASSIGN()
                current += self.acmeConnectorBody()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.SEMICOLON()

            elif choice == 1:
                current += self.unlexer.EXTENDS()
                current += self.acmeConnectorTypeRef()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmeConnectorTypeRef()

                choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_472', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_472', choice)] = self.unlexer.weights.get(('alt_472', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.SEMICOLON()
                elif choice == 1:
                    current += self.unlexer.WITH()
                    current += self.acmeConnectorBody()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_one():
                            current += self.unlexer.SEMICOLON()

        return current
    acmeConnectorTypeDeclaration.min_depth = 2

    @depthcontrol
    def acmeConnectorDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeConnectorDeclaration'))
        current += self.unlexer.CONNECTOR()
        current += self.identifier()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.COLON()
                current += self.acmeConnectorTypeRef()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmeConnectorTypeRef()


        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_478', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_478', choice)] = self.unlexer.weights.get(('alt_478', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SEMICOLON()
        elif choice == 1:
            current += self.unlexer.ASSIGN()
            choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_481', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_481', choice)] = self.unlexer.weights.get(('alt_481', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.acmeConnectorBody()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.SEMICOLON()

            elif choice == 1:
                current += self.unlexer.NEW()
                current += self.acmeConnectorInstantiatedTypeRef()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmeConnectorInstantiatedTypeRef()

                choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_486', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_486', choice)] = self.unlexer.weights.get(('alt_486', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.SEMICOLON()
                elif choice == 1:
                    current += self.unlexer.EXTENDED()
                    current += self.unlexer.WITH()
                    current += self.acmeConnectorBody()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_one():
                            current += self.unlexer.SEMICOLON()

        return current
    acmeConnectorDeclaration.min_depth = 2

    @depthcontrol
    def acmeConnectorBody(self):
        current = self.create_node(UnparserRule(name='acmeConnectorBody'))
        current += self.unlexer.LBRACE()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [3, 3, 2, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_491', i), 1) for i, w in enumerate([1, 1, 1, 1])])
                self.unlexer.weights[('alt_491', choice)] = self.unlexer.weights.get(('alt_491', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.acmePropertyDeclaration()
                elif choice == 1:
                    current += self.acmeRoleDeclaration()
                elif choice == 2:
                    current += self.designRule()
                elif choice == 3:
                    current += self.acmeRepresentationDeclaration()

        current += self.unlexer.RBRACE()
        return current
    acmeConnectorBody.min_depth = 1

    @depthcontrol
    def acmeRepresentationDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeRepresentationDeclaration'))
        current += self.unlexer.REPRESENTATION()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.IDENTIFIER()
                current += self.unlexer.ASSIGN()

        current += self.unlexer.LBRACE()
        current += self.acmeSystemDeclaration()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.acmeBindingsMapDeclaration()

        current += self.unlexer.RBRACE()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.SEMICOLON()

        return current
    acmeRepresentationDeclaration.min_depth = 3

    @depthcontrol
    def acmeBindingsMapDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeBindingsMapDeclaration'))
        current += self.unlexer.BINDINGS()
        current += self.unlexer.LBRACE()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.acmeBindingDeclaration()

        current += self.unlexer.RBRACE()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.SEMICOLON()

        return current
    acmeBindingsMapDeclaration.min_depth = 2

    @depthcontrol
    def acmeBindingDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeBindingDeclaration'))
        current += self.acmeInstanceRef()
        current += self.unlexer.TO()
        current += self.acmeInstanceRef()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.unlexer.LBRACE()
                current += self.acmePropertyDeclaration()
                current += self.acmePropertyBlock()
                current += self.unlexer.RBRACE()

        current += self.unlexer.SEMICOLON()
        return current
    acmeBindingDeclaration.min_depth = 2

    @depthcontrol
    def acmeAttachmentDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeAttachmentDeclaration'))
        current += self.unlexer.ATTACHMENT()
        current += self.acmeInstanceRef()
        current += self.unlexer.TO()
        current += self.acmeInstanceRef()
        current += self.unlexer.SEMICOLON()
        return current
    acmeAttachmentDeclaration.min_depth = 2

    @depthcontrol
    def acmePropertyDeclaration(self):
        current = self.create_node(UnparserRule(name='acmePropertyDeclaration'))
        current += self.unlexer.PROPERTY()
        current += self.identifier()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.unlexer.COLON()
                current += self.acmePropertyTypeRef()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_504', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_504', choice)] = self.unlexer.weights.get(('alt_504', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.ASSIGN()
                    current += self.acmePropertyValueDeclaration()
                elif choice == 1:
                    current += self.unlexer.CONTAINASSIGN()
                    current += self.acmePropertyValueDeclaration()

        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.acmePropertyBlock()

        current += self.unlexer.SEMICOLON()
        return current
    acmePropertyDeclaration.min_depth = 2

    @depthcontrol
    def acmePropertyValueDeclaration(self):
        current = self.create_node(UnparserRule(name='acmePropertyValueDeclaration'))
        choice = self.choice([0 if [1, 1, 1, 2, 2, 2, 2, 2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_508', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_508', choice)] = self.unlexer.weights.get(('alt_508', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.INTEGER_LITERAL()
        elif choice == 1:
            current += self.unlexer.FLOATING_POINT_LITERAL()
        elif choice == 2:
            current += self.unlexer.STRING_LITERAL()
        elif choice == 3:
            current += self.unlexer.FALSE()
        elif choice == 4:
            current += self.unlexer.TRUE()
        elif choice == 5:
            current += self.acmePropertySet()
        elif choice == 6:
            current += self.acmePropertyRecord()
        elif choice == 7:
            current += self.acmePropertySequence()
        elif choice == 8:
            current += self.enumidentifier()
        return current
    acmePropertyValueDeclaration.min_depth = 1

    @depthcontrol
    def enumidentifier(self):
        current = self.create_node(UnparserRule(name='enumidentifier'))
        current += self.unlexer.IDENTIFIER()
        return current
    enumidentifier.min_depth = 1

    @depthcontrol
    def acmePropertyElement(self):
        current = self.create_node(UnparserRule(name='acmePropertyElement'))
        choice = self.choice([0 if [1, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_518', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_518', choice)] = self.unlexer.weights.get(('alt_518', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.IDENTIFIER()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.create_node(UnlexerRule(src='.'))
                    current += self.unlexer.IDENTIFIER()

        elif choice == 1:
            current += self.acmePropertyCompoundElement()
        return current
    acmePropertyElement.min_depth = 1

    @depthcontrol
    def acmePropertyCompoundElement(self):
        current = self.create_node(UnparserRule(name='acmePropertyCompoundElement'))
        choice = self.choice([0 if [2, 2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_523', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_523', choice)] = self.unlexer.weights.get(('alt_523', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.acmePropertySet()
        elif choice == 1:
            current += self.acmePropertyRecord()
        elif choice == 2:
            current += self.acmePropertySequence()
        return current
    acmePropertyCompoundElement.min_depth = 2

    @depthcontrol
    def acmePropertySet(self):
        current = self.create_node(UnparserRule(name='acmePropertySet'))
        current += self.unlexer.LBRACE()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.acmePropertyValueDeclaration()
                if self.unlexer.max_depth >= 2:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmePropertyValueDeclaration()


        current += self.unlexer.RBRACE()
        return current
    acmePropertySet.min_depth = 1

    @depthcontrol
    def acmePropertyRecordEntry(self):
        current = self.create_node(UnparserRule(name='acmePropertyRecordEntry'))
        current += self.identifier()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.unlexer.COLON()
                current += self.acmePropertyTypeRef()

        current += self.unlexer.ASSIGN()
        current += self.acmePropertyValueDeclaration()
        return current
    acmePropertyRecordEntry.min_depth = 2

    @depthcontrol
    def acmePropertyRecord(self):
        current = self.create_node(UnparserRule(name='acmePropertyRecord'))
        current += self.unlexer.LBRACKET()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.acmePropertyRecordEntry()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.SEMICOLON()
                        current += self.acmePropertyRecordEntry()

                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.SEMICOLON()


        current += self.unlexer.RBRACKET()
        return current
    acmePropertyRecord.min_depth = 1

    @depthcontrol
    def acmePropertySequence(self):
        current = self.create_node(UnparserRule(name='acmePropertySequence'))
        current += self.unlexer.LANGLE()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.acmePropertyValueDeclaration()
                if self.unlexer.max_depth >= 2:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.acmePropertyValueDeclaration()


        current += self.unlexer.RANGLE()
        return current
    acmePropertySequence.min_depth = 1

    @depthcontrol
    def acmePropertyTypeRecord(self):
        current = self.create_node(UnparserRule(name='acmePropertyTypeRecord'))
        current += self.unlexer.RECORD()
        current += self.unlexer.LBRACKET()
        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_more():
                current += self.acmePropertyRecordFieldDescription()

        current += self.unlexer.RBRACKET()
        return current
    acmePropertyTypeRecord.min_depth = 2

    @depthcontrol
    def acmePropertyTypeSet(self):
        current = self.create_node(UnparserRule(name='acmePropertyTypeSet'))
        current += self.unlexer.SET()
        current += self.unlexer.LBRACE()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.acmeTypeRef()

        current += self.unlexer.RBRACE()
        return current
    acmePropertyTypeSet.min_depth = 2

    @depthcontrol
    def acmePropertyTypeSequence(self):
        current = self.create_node(UnparserRule(name='acmePropertyTypeSequence'))
        current += self.unlexer.SEQUENCE()
        current += self.unlexer.LANGLE()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.acmePropertyTypeRef()

        current += self.unlexer.RANGLE()
        return current
    acmePropertyTypeSequence.min_depth = 2

    @depthcontrol
    def acmePropertyTypeEnum(self):
        current = self.create_node(UnparserRule(name='acmePropertyTypeEnum'))
        current += self.unlexer.ENUM()
        current += self.unlexer.LBRACE()
        current += self.identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.unlexer.COMMA()
                current += self.identifier()

        current += self.unlexer.RBRACE()
        return current
    acmePropertyTypeEnum.min_depth = 2

    @depthcontrol
    def acmePropertyRecordFieldDescription(self):
        current = self.create_node(UnparserRule(name='acmePropertyRecordFieldDescription'))
        current += self.identifier()
        current += self.unlexer.COLON()
        current += self.acmePropertyTypeRef()
        current += self.unlexer.SEMICOLON()
        return current
    acmePropertyRecordFieldDescription.min_depth = 4

    @depthcontrol
    def acmePropertyTypeRef(self):
        current = self.create_node(UnparserRule(name='acmePropertyTypeRef'))
        choice = self.choice([0 if [4, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_539', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_539', choice)] = self.unlexer.weights.get(('alt_539', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.acmePropertyTypeStructure()
        elif choice == 1:
            current += self.acmePropertyTypeDeclarationRef()
        return current
    acmePropertyTypeRef.min_depth = 3

    @depthcontrol
    def acmePropertyTypeStructure(self):
        current = self.create_node(UnparserRule(name='acmePropertyTypeStructure'))
        choice = self.choice([0 if [3, 3, 3, 3, 3, 4, 3, 3, 3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_542', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_542', choice)] = self.unlexer.weights.get(('alt_542', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.acmePropertyTypeAny()
        elif choice == 1:
            current += self.acmePropertyTypeInt()
        elif choice == 2:
            current += self.acmePropertyTypeFloat()
        elif choice == 3:
            current += self.acmePropertyTypeDouble()
        elif choice == 4:
            current += self.acmePropertyTypeString()
        elif choice == 5:
            current += self.acmePropertyTypeBoolean()
        elif choice == 6:
            current += self.acmePropertyTypeRecord()
        elif choice == 7:
            current += self.acmePropertyTypeSet()
        elif choice == 8:
            current += self.acmePropertyTypeSequence()
        elif choice == 9:
            current += self.acmePropertyTypeEnum()
        return current
    acmePropertyTypeStructure.min_depth = 3

    @depthcontrol
    def acmePropertyTypeDeclaration(self):
        current = self.create_node(UnparserRule(name='acmePropertyTypeDeclaration'))
        current += self.unlexer.PROPERTY()
        current += self.unlexer.TYPE()
        current += self.identifier()
        choice = self.choice([0 if [1, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_553', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_553', choice)] = self.unlexer.weights.get(('alt_553', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SEMICOLON()
        elif choice == 1:
            current += self.unlexer.ASSIGN()
            choice = self.choice([0 if [3, 3, 3, 3, 4, 3, 3, 3, 3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_556', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
            self.unlexer.weights[('alt_556', choice)] = self.unlexer.weights.get(('alt_556', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.acmePropertyTypeInt()
            elif choice == 1:
                current += self.acmePropertyTypeFloat()
            elif choice == 2:
                current += self.acmePropertyTypeDouble()
            elif choice == 3:
                current += self.acmePropertyTypeString()
            elif choice == 4:
                current += self.acmePropertyTypeBoolean()
            elif choice == 5:
                current += self.acmePropertyTypeRecord()
            elif choice == 6:
                current += self.acmePropertyTypeSet()
            elif choice == 7:
                current += self.acmePropertyTypeSequence()
            elif choice == 8:
                current += self.acmePropertyTypeEnum()
            elif choice == 9:
                current += self.acmePropertyTypeAny()
            current += self.unlexer.SEMICOLON()
        return current
    acmePropertyTypeDeclaration.min_depth = 2

    @depthcontrol
    def acmePropertyBlockEntry(self):
        current = self.create_node(UnparserRule(name='acmePropertyBlockEntry'))
        current += self.identifier()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.unlexer.COLON()
                current += self.acmePropertyTypeRef()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_569', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_569', choice)] = self.unlexer.weights.get(('alt_569', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.ASSIGN()
                    current += self.acmePropertyValueDeclaration()
                elif choice == 1:
                    current += self.unlexer.CONTAINASSIGN()
                    current += self.acmePropertyValueDeclaration()

        current += self.unlexer.SEMICOLON()
        return current
    acmePropertyBlockEntry.min_depth = 2

    @depthcontrol
    def acmePropertyBlock(self):
        current = self.create_node(UnparserRule(name='acmePropertyBlock'))
        current += self.unlexer.PROPBEGIN()
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.acmePropertyBlockEntry()

        current += self.unlexer.PROPEND()
        return current
    acmePropertyBlock.min_depth = 3

    @depthcontrol
    def acmePropertyTypeInt(self):
        current = self.create_node(UnparserRule(name='acmePropertyTypeInt'))
        current += self.unlexer.INT()
        return current
    acmePropertyTypeInt.min_depth = 2

    @depthcontrol
    def acmePropertyTypeAny(self):
        current = self.create_node(UnparserRule(name='acmePropertyTypeAny'))
        current += self.unlexer.ANY()
        return current
    acmePropertyTypeAny.min_depth = 2

    @depthcontrol
    def acmePropertyTypeFloat(self):
        current = self.create_node(UnparserRule(name='acmePropertyTypeFloat'))
        current += self.unlexer.FLOAT()
        return current
    acmePropertyTypeFloat.min_depth = 2

    @depthcontrol
    def acmePropertyTypeDouble(self):
        current = self.create_node(UnparserRule(name='acmePropertyTypeDouble'))
        current += self.unlexer.DOUBLE()
        return current
    acmePropertyTypeDouble.min_depth = 2

    @depthcontrol
    def acmePropertyTypeString(self):
        current = self.create_node(UnparserRule(name='acmePropertyTypeString'))
        current += self.unlexer.STRING()
        return current
    acmePropertyTypeString.min_depth = 2

    @depthcontrol
    def acmePropertyTypeBoolean(self):
        current = self.create_node(UnparserRule(name='acmePropertyTypeBoolean'))
        current += self.unlexer.BOOLEAN()
        return current
    acmePropertyTypeBoolean.min_depth = 3

    @depthcontrol
    def acmeViewDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeViewDeclaration'))
        current += self.unlexer.VIEW()
        current += self.identifier()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.COLON()
                current += self.acmeViewTypeRef()

        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_573', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_573', choice)] = self.unlexer.weights.get(('alt_573', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SEMICOLON()
        elif choice == 1:
            current += self.unlexer.ASSIGN()
            choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_576', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_576', choice)] = self.unlexer.weights.get(('alt_576', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.acmeViewBody()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.SEMICOLON()

            elif choice == 1:
                current += self.unlexer.NEW()
                current += self.acmeViewInstantiatedTypeRef()
                choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_580', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_580', choice)] = self.unlexer.weights.get(('alt_580', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.SEMICOLON()
                elif choice == 1:
                    current += self.unlexer.EXTENDED()
                    current += self.unlexer.WITH()
                    current += self.acmeViewBody()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_one():
                            current += self.unlexer.SEMICOLON()

        return current
    acmeViewDeclaration.min_depth = 2

    @depthcontrol
    def acmeViewTypeDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeViewTypeDeclaration'))
        current += self.unlexer.VIEW()
        current += self.unlexer.TYPE()
        current += self.identifier()
        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_584', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_584', choice)] = self.unlexer.weights.get(('alt_584', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SEMICOLON()
        elif choice == 1:
            choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_587', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_587', choice)] = self.unlexer.weights.get(('alt_587', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.unlexer.ASSIGN()
                current += self.acmeViewBody()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.SEMICOLON()

            elif choice == 1:
                current += self.unlexer.EXTENDS()
                current += self.acmeViewTypeRef()
                choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_591', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_591', choice)] = self.unlexer.weights.get(('alt_591', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.SEMICOLON()
                elif choice == 1:
                    current += self.unlexer.WITH()
                    current += self.acmeViewBody()
                    if self.unlexer.max_depth >= 1:
                        for _ in self.zero_or_one():
                            current += self.unlexer.SEMICOLON()

        return current
    acmeViewTypeDeclaration.min_depth = 2

    @depthcontrol
    def acmeViewBody(self):
        current = self.create_node(UnparserRule(name='acmeViewBody'))
        current += self.unlexer.LBRACE()
        current += self.unlexer.RBRACE()
        return current
    acmeViewBody.min_depth = 1

    @depthcontrol
    def designRule(self):
        current = self.create_node(UnparserRule(name='designRule'))
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.DESIGN()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.RULE()
                current += self.unlexer.IDENTIFIER()
                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.ASSIGN()


        if self.unlexer.max_depth >= 13:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [13, 13][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_599', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_599', choice)] = self.unlexer.weights.get(('alt_599', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.INVARIANT()
                    current += self.designRuleExpression()
                elif choice == 1:
                    current += self.unlexer.HEURISTIC()
                    current += self.designRuleExpression()

        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.acmePropertyBlock()

        current += self.unlexer.SEMICOLON()
        return current
    designRule.min_depth = 1

    @depthcontrol
    def acmeDesignAnalysisDeclaration(self):
        current = self.create_node(UnparserRule(name='acmeDesignAnalysisDeclaration'))
        choice = self.choice([0 if [13, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_603', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_603', choice)] = self.unlexer.weights.get(('alt_603', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.unlexer.DESIGN()

            current += self.unlexer.ANALYSIS()
            current += self.unlexer.IDENTIFIER()
            current += self.unlexer.LPAREN()
            if self.unlexer.max_depth >= 4:
                for _ in self.zero_or_one():
                    current += self.formalParam()
                    if self.unlexer.max_depth >= 4:
                        for _ in self.zero_or_more():
                            current += self.unlexer.COMMA()
                            current += self.formalParam()


            current += self.unlexer.RPAREN()
            current += self.unlexer.COLON()
            current += self.acmeTypeRef()
            current += self.unlexer.ASSIGN()
            current += self.designRuleExpression()
            if self.unlexer.max_depth >= 4:
                for _ in self.zero_or_one():
                    current += self.acmePropertyBlock()

            current += self.unlexer.SEMICOLON()
        elif choice == 1:
            current += self.unlexer.EXTERNAL()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.unlexer.DESIGN()

            current += self.unlexer.ANALYSIS()
            current += self.unlexer.IDENTIFIER()
            current += self.unlexer.LPAREN()
            if self.unlexer.max_depth >= 4:
                for _ in self.zero_or_one():
                    current += self.formalParam()
                    if self.unlexer.max_depth >= 4:
                        for _ in self.zero_or_more():
                            current += self.unlexer.COMMA()
                            current += self.formalParam()


            current += self.unlexer.RPAREN()
            current += self.unlexer.COLON()
            current += self.acmeTypeRef()
            current += self.unlexer.ASSIGN()
            choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_613', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_613', choice)] = self.unlexer.weights.get(('alt_613', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.codeLiteral()
            elif choice == 1:
                current += self.identifier()
                if self.unlexer.max_depth >= 2:
                    for _ in self.zero_or_more():
                        current += self.unlexer.DOT()
                        current += self.identifier()

            current += self.unlexer.SEMICOLON()
        return current
    acmeDesignAnalysisDeclaration.min_depth = 3

    @depthcontrol
    def formalParam(self):
        current = self.create_node(UnparserRule(name='formalParam'))
        current += self.identifier()
        current += self.unlexer.COLON()
        current += self.acmeTypeRef()
        return current
    formalParam.min_depth = 3

    @depthcontrol
    def terminatedDesignRuleExpression(self):
        current = self.create_node(UnparserRule(name='terminatedDesignRuleExpression'))
        current += self.designRuleExpression()
        current += self.unlexer.SEMICOLON()
        return current
    terminatedDesignRuleExpression.min_depth = 13

    @depthcontrol
    def designRuleExpression(self):
        current = self.create_node(UnparserRule(name='designRuleExpression'))
        current += self.aSTDRImpliesExpression()
        if self.unlexer.max_depth >= 12:
            for _ in self.zero_or_more():
                current += self.unlexer.OR()
                current += self.aSTDRImpliesExpression()

        return current
    designRuleExpression.min_depth = 12

    @depthcontrol
    def aSTDRImpliesExpression(self):
        current = self.create_node(UnparserRule(name='aSTDRImpliesExpression'))
        current += self.dRIffExpression()
        if self.unlexer.max_depth >= 11:
            for _ in self.zero_or_more():
                current += self.unlexer.IMPLIES()
                current += self.dRIffExpression()

        return current
    aSTDRImpliesExpression.min_depth = 11

    @depthcontrol
    def dRIffExpression(self):
        current = self.create_node(UnparserRule(name='dRIffExpression'))
        current += self.dRAndExpression()
        if self.unlexer.max_depth >= 10:
            for _ in self.zero_or_more():
                current += self.unlexer.IFF()
                current += self.dRAndExpression()

        return current
    dRIffExpression.min_depth = 10

    @depthcontrol
    def dRAndExpression(self):
        current = self.create_node(UnparserRule(name='dRAndExpression'))
        current += self.dRNegateExpression()
        if self.unlexer.max_depth >= 9:
            for _ in self.zero_or_more():
                current += self.unlexer.AND()
                current += self.dRNegateExpression()

        return current
    dRAndExpression.min_depth = 9

    @depthcontrol
    def dRNegateExpression(self):
        current = self.create_node(UnparserRule(name='dRNegateExpression'))
        choice = self.choice([0 if [9, 8][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_621', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_621', choice)] = self.unlexer.weights.get(('alt_621', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.BANG()
            current += self.dRNegateExpression()
        elif choice == 1:
            current += self.dREqualityExpression()
        return current
    dRNegateExpression.min_depth = 8

    @depthcontrol
    def dREqualityExpression(self):
        current = self.create_node(UnparserRule(name='dREqualityExpression'))
        current += self.dRRelationalExpression()
        if self.unlexer.max_depth >= 7:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [7, 7][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_625', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_625', choice)] = self.unlexer.weights.get(('alt_625', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.EQ()
                    current += self.dRRelationalExpression()
                elif choice == 1:
                    current += self.unlexer.NE()
                    current += self.dRRelationalExpression()

        return current
    dREqualityExpression.min_depth = 7

    @depthcontrol
    def dRRelationalExpression(self):
        current = self.create_node(UnparserRule(name='dRRelationalExpression'))
        current += self.dRAdditiveExpression()
        if self.unlexer.max_depth >= 6:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [6, 6, 6, 6][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_629', i), 1) for i, w in enumerate([1, 1, 1, 1])])
                self.unlexer.weights[('alt_629', choice)] = self.unlexer.weights.get(('alt_629', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.LANGLE()
                    current += self.dRAdditiveExpression()
                elif choice == 1:
                    current += self.unlexer.RANGLE()
                    current += self.dRAdditiveExpression()
                elif choice == 2:
                    current += self.unlexer.LE()
                    current += self.dRAdditiveExpression()
                elif choice == 3:
                    current += self.unlexer.GE()
                    current += self.dRAdditiveExpression()

        return current
    dRRelationalExpression.min_depth = 6

    @depthcontrol
    def dRAdditiveExpression(self):
        current = self.create_node(UnparserRule(name='dRAdditiveExpression'))
        current += self.dRMultiplicativeExpression()
        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [5, 5][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_635', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_635', choice)] = self.unlexer.weights.get(('alt_635', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.PLUS()
                    current += self.dRMultiplicativeExpression()
                elif choice == 1:
                    current += self.unlexer.MINUS()
                    current += self.dRMultiplicativeExpression()

        return current
    dRAdditiveExpression.min_depth = 5

    @depthcontrol
    def dRMultiplicativeExpression(self):
        current = self.create_node(UnparserRule(name='dRMultiplicativeExpression'))
        current += self.dRNegativeExpression()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [4, 4, 4, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_639', i), 1) for i, w in enumerate([1, 1, 1, 1])])
                self.unlexer.weights[('alt_639', choice)] = self.unlexer.weights.get(('alt_639', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.STAR()
                    current += self.dRNegativeExpression()
                elif choice == 1:
                    current += self.unlexer.SLASH()
                    current += self.dRNegativeExpression()
                elif choice == 2:
                    current += self.unlexer.REM()
                    current += self.dRNegativeExpression()
                elif choice == 3:
                    current += self.unlexer.POWER()
                    current += self.dRNegativeExpression()

        return current
    dRMultiplicativeExpression.min_depth = 4

    @depthcontrol
    def dRNegativeExpression(self):
        current = self.create_node(UnparserRule(name='dRNegativeExpression'))
        choice = self.choice([0 if [4, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_644', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_644', choice)] = self.unlexer.weights.get(('alt_644', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.MINUS()
            current += self.dRNegativeExpression()
        elif choice == 1:
            current += self.primitiveExpression()
        return current
    dRNegativeExpression.min_depth = 3

    @depthcontrol
    def primitiveExpression(self):
        current = self.create_node(UnparserRule(name='primitiveExpression'))
        choice = self.choice([0 if [2, 3, 14, 3, 2, 2, 14, 5][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_647', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_647', choice)] = self.unlexer.weights.get(('alt_647', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.literalConstant()
        elif choice == 1:
            current += self.reference()
        elif choice == 2:
            current += self.parentheticalExpression()
        elif choice == 3:
            current += self.setExpression()
        elif choice == 4:
            current += self.literalSequence()
        elif choice == 5:
            current += self.literalRecord()
        elif choice == 6:
            current += self.quantifiedExpression()
        elif choice == 7:
            current += self.sequenceExpression()
        return current
    primitiveExpression.min_depth = 2

    @depthcontrol
    def parentheticalExpression(self):
        current = self.create_node(UnparserRule(name='parentheticalExpression'))
        current += self.unlexer.LPAREN()
        current += self.designRuleExpression()
        current += self.unlexer.RPAREN()
        return current
    parentheticalExpression.min_depth = 13

    @depthcontrol
    def reference(self):
        current = self.create_node(UnparserRule(name='reference'))
        current += self.identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.unlexer.DOT()
                choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_657', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_657', choice)] = self.unlexer.weights.get(('alt_657', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.identifier()
                elif choice == 1:
                    current += self.setReference()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.actualParams()

        return current
    reference.min_depth = 2

    @depthcontrol
    def setReference(self):
        current = self.create_node(UnparserRule(name='setReference'))
        choice = self.choice([0 if [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_661', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_661', choice)] = self.unlexer.weights.get(('alt_661', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.TYPE()
        elif choice == 1:
            current += self.unlexer.COMPONENTS()
        elif choice == 2:
            current += self.unlexer.CONNECTORS()
        elif choice == 3:
            current += self.unlexer.PORTS()
        elif choice == 4:
            current += self.unlexer.ROLES()
        elif choice == 5:
            current += self.unlexer.GROUPS()
        elif choice == 6:
            current += self.unlexer.MEMBERS()
        elif choice == 7:
            current += self.unlexer.PROPERTIES()
        elif choice == 8:
            current += self.unlexer.REPRESENTATIONS()
        elif choice == 9:
            current += self.unlexer.ATTACHEDPORTS()
        elif choice == 10:
            current += self.unlexer.ATTACHEDROLES()
        return current
    setReference.min_depth = 2

    @depthcontrol
    def actualParams(self):
        current = self.create_node(UnparserRule(name='actualParams'))
        current += self.unlexer.LPAREN()
        if self.unlexer.max_depth >= 13:
            for _ in self.zero_or_one():
                current += self.designRuleExpression()
                if self.unlexer.max_depth >= 13:
                    for _ in self.zero_or_more():
                        current += self.unlexer.COMMA()
                        current += self.designRuleExpression()


        current += self.unlexer.RPAREN()
        return current
    actualParams.min_depth = 1

    @depthcontrol
    def literalConstant(self):
        current = self.create_node(UnparserRule(name='literalConstant'))
        choice = self.choice([0 if [1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_675', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_675', choice)] = self.unlexer.weights.get(('alt_675', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.INTEGER_LITERAL()
        elif choice == 1:
            current += self.unlexer.FLOATING_POINT_LITERAL()
        elif choice == 2:
            current += self.unlexer.STRING_LITERAL()
        elif choice == 3:
            current += self.unlexer.TRUE()
        elif choice == 4:
            current += self.unlexer.FALSE()
        elif choice == 5:
            current += self.unlexer.COMPONENT()
        elif choice == 6:
            current += self.unlexer.GROUP()
        elif choice == 7:
            current += self.unlexer.CONNECTOR()
        elif choice == 8:
            current += self.unlexer.PORT()
        elif choice == 9:
            current += self.unlexer.ROLE()
        elif choice == 10:
            current += self.unlexer.SYSTEM()
        elif choice == 11:
            current += self.unlexer.ELEMENT()
        elif choice == 12:
            current += self.unlexer.PROPERTY()
        elif choice == 13:
            current += self.unlexer.INT()
        elif choice == 14:
            current += self.unlexer.FLOAT()
        elif choice == 15:
            current += self.unlexer.DOUBLE()
        elif choice == 16:
            current += self.unlexer.STRING()
        elif choice == 17:
            current += self.unlexer.BOOLEAN()
        elif choice == 18:
            current += self.unlexer.ENUM()
        elif choice == 19:
            current += self.unlexer.SET()
        elif choice == 20:
            current += self.unlexer.SEQUENCE()
        elif choice == 21:
            current += self.unlexer.RECORD()
        return current
    literalConstant.min_depth = 1

    @depthcontrol
    def quantifiedExpression(self):
        current = self.create_node(UnparserRule(name='quantifiedExpression'))
        choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_698', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_698', choice)] = self.unlexer.weights.get(('alt_698', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.FORALL()
        elif choice == 1:
            current += self.unlexer.EXISTS()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.unlexer.UNIQUE()

        current += self.variableSetDeclaration()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.unlexer.COMMA()
                current += self.variableSetDeclaration()

        current += self.unlexer.BIT_OR()
        current += self.designRuleExpression()
        return current
    quantifiedExpression.min_depth = 13

    @depthcontrol
    def distinctVariableSetDeclaration(self):
        current = self.create_node(UnparserRule(name='distinctVariableSetDeclaration'))
        current += self.unlexer.DISTINCT()
        current += self.identifier()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.unlexer.COMMA()
                current += self.identifier()

        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_705', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_705', choice)] = self.unlexer.weights.get(('alt_705', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.COLON()
                elif choice == 1:
                    current += self.unlexer.SET_DECLARE()
                current += self.acmeTypeRef()

        current += self.unlexer.IN()
        choice = self.choice([0 if [3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_708', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_708', choice)] = self.unlexer.weights.get(('alt_708', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.setExpression()
        elif choice == 1:
            current += self.reference()
        return current
    distinctVariableSetDeclaration.min_depth = 3

    @depthcontrol
    def variableSetDeclaration(self):
        current = self.create_node(UnparserRule(name='variableSetDeclaration'))
        choice = self.choice([0 if [4, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_711', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_711', choice)] = self.unlexer.weights.get(('alt_711', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.distinctVariableSetDeclaration()
        elif choice == 1:
            current += self.identifier()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_more():
                    current += self.unlexer.COMMA()
                    current += self.identifier()

            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_one():
                    choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_716', i), 1) for i, w in enumerate([1, 1])])
                    self.unlexer.weights[('alt_716', choice)] = self.unlexer.weights.get(('alt_716', choice), 1) * self.unlexer.cooldown
                    if choice == 0:
                        current += self.unlexer.COLON()
                    elif choice == 1:
                        current += self.unlexer.SET_DECLARE()
                    current += self.acmeTypeRef()

            current += self.unlexer.IN()
            choice = self.choice([0 if [3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_719', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_719', choice)] = self.unlexer.weights.get(('alt_719', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.setExpression()
            elif choice == 1:
                current += self.reference()
        return current
    variableSetDeclaration.min_depth = 3

    @depthcontrol
    def sequenceExpression(self):
        current = self.create_node(UnparserRule(name='sequenceExpression'))
        current += self.unlexer.LANGLE()
        current += self.pathExpression()
        current += self.unlexer.RANGLE()
        return current
    sequenceExpression.min_depth = 4

    @depthcontrol
    def setExpression(self):
        current = self.create_node(UnparserRule(name='setExpression'))
        choice = self.choice([0 if [2, 14, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_722', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_722', choice)] = self.unlexer.weights.get(('alt_722', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.literalSet()
        elif choice == 1:
            current += self.setConstructor()
        elif choice == 2:
            current += self.pathExpression()
        return current
    setExpression.min_depth = 2

    @depthcontrol
    def pathExpression(self):
        current = self.create_node(UnparserRule(name='pathExpression'))
        current += self.unlexer.SLASH()
        current += self.reference()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_727', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_727', choice)] = self.unlexer.weights.get(('alt_727', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.COLON()
                elif choice == 1:
                    current += self.unlexer.SET_DECLARE()
                current += self.acmeTypeRef()

        if self.unlexer.max_depth >= 13:
            for _ in self.zero_or_one():
                current += self.unlexer.LBRACKET()
                current += self.designRuleExpression()
                current += self.unlexer.RBRACKET()

        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.unlexer.SLASH()
                current += self.pathExpressionContinuation()

        return current
    pathExpression.min_depth = 3

    @depthcontrol
    def pathExpressionContinuation(self):
        current = self.create_node(UnparserRule(name='pathExpressionContinuation'))
        choice = self.choice([0 if [3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_732', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_732', choice)] = self.unlexer.weights.get(('alt_732', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.setReference()
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_one():
                    choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_736', i), 1) for i, w in enumerate([1, 1])])
                    self.unlexer.weights[('alt_736', choice)] = self.unlexer.weights.get(('alt_736', choice), 1) * self.unlexer.cooldown
                    if choice == 0:
                        current += self.unlexer.COLON()
                    elif choice == 1:
                        current += self.unlexer.SET_DECLARE()
                    current += self.acmeTypeRef()

            if self.unlexer.max_depth >= 13:
                for _ in self.zero_or_one():
                    current += self.unlexer.LBRACKET()
                    current += self.designRuleExpression()
                    current += self.unlexer.RBRACKET()

            if self.unlexer.max_depth >= 4:
                for _ in self.zero_or_more():
                    current += self.unlexer.SLASH()
                    current += self.pathExpressionContinuation()

        elif choice == 1:
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.unlexer.ELLIPSIS()

            current += self.reference()
        return current
    pathExpressionContinuation.min_depth = 3

    @depthcontrol
    def literalSet(self):
        current = self.create_node(UnparserRule(name='literalSet'))
        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_742', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_742', choice)] = self.unlexer.weights.get(('alt_742', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.LBRACE()
            current += self.unlexer.RBRACE()
        elif choice == 1:
            current += self.unlexer.LBRACE()
            choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_745', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_745', choice)] = self.unlexer.weights.get(('alt_745', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.literalConstant()
            elif choice == 1:
                current += self.reference()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_more():
                    current += self.unlexer.COMMA()
                    choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_749', i), 1) for i, w in enumerate([1, 1])])
                    self.unlexer.weights[('alt_749', choice)] = self.unlexer.weights.get(('alt_749', choice), 1) * self.unlexer.cooldown
                    if choice == 0:
                        current += self.literalConstant()
                    elif choice == 1:
                        current += self.reference()

            current += self.unlexer.RBRACE()
        return current
    literalSet.min_depth = 1

    @depthcontrol
    def literalSequence(self):
        current = self.create_node(UnparserRule(name='literalSequence'))
        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_752', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_752', choice)] = self.unlexer.weights.get(('alt_752', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.LANGLE()
            current += self.unlexer.RANGLE()
        elif choice == 1:
            current += self.unlexer.LANGLE()
            choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_755', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_755', choice)] = self.unlexer.weights.get(('alt_755', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.literalConstant()
            elif choice == 1:
                current += self.reference()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_more():
                    current += self.unlexer.COMMA()
                    choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_759', i), 1) for i, w in enumerate([1, 1])])
                    self.unlexer.weights[('alt_759', choice)] = self.unlexer.weights.get(('alt_759', choice), 1) * self.unlexer.cooldown
                    if choice == 0:
                        current += self.literalConstant()
                    elif choice == 1:
                        current += self.reference()

            current += self.unlexer.RANGLE()
        return current
    literalSequence.min_depth = 1

    @depthcontrol
    def literalRecordEntry(self):
        current = self.create_node(UnparserRule(name='literalRecordEntry'))
        current += self.identifier()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.unlexer.COLON()
                current += self.acmePropertyTypeRef()

        current += self.unlexer.ASSIGN()
        current += self.literalConstant()
        return current
    literalRecordEntry.min_depth = 2

    @depthcontrol
    def literalRecord(self):
        current = self.create_node(UnparserRule(name='literalRecord'))
        current += self.unlexer.LBRACKET()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.literalRecordEntry()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.unlexer.SEMICOLON()
                        current += self.literalRecordEntry()

                if self.unlexer.max_depth >= 1:
                    for _ in self.zero_or_one():
                        current += self.unlexer.SEMICOLON()


        current += self.unlexer.RBRACKET()
        return current
    literalRecord.min_depth = 1

    @depthcontrol
    def setConstructor(self):
        current = self.create_node(UnparserRule(name='setConstructor'))
        choice = self.choice([0 if [13, 13][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_766', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_766', choice)] = self.unlexer.weights.get(('alt_766', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.unlexer.LBRACE()

            current += self.unlexer.SELECT()
            current += self.variableSetDeclaration()
            current += self.unlexer.BIT_OR()
            current += self.designRuleExpression()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.unlexer.RBRACE()

        elif choice == 1:
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.unlexer.LBRACE()

            current += self.unlexer.COLLECT()
            current += self.reference()
            current += self.unlexer.COLON()
            current += self.acmeTypeRef()
            current += self.unlexer.IN()
            choice = self.choice([0 if [3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_772', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_772', choice)] = self.unlexer.weights.get(('alt_772', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.setExpression()
            elif choice == 1:
                current += self.reference()
            current += self.unlexer.BIT_OR()
            current += self.designRuleExpression()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.unlexer.RBRACE()

        return current
    setConstructor.min_depth = 13

    @depthcontrol
    def acmeTypeRef(self):
        current = self.create_node(UnparserRule(name='acmeTypeRef'))
        choice = self.choice([0 if [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_776', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_776', choice)] = self.unlexer.weights.get(('alt_776', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SYSTEM()
        elif choice == 1:
            current += self.unlexer.COMPONENT()
        elif choice == 2:
            current += self.unlexer.GROUP()
        elif choice == 3:
            current += self.unlexer.CONNECTOR()
        elif choice == 4:
            current += self.unlexer.PORT()
        elif choice == 5:
            current += self.unlexer.ROLE()
        elif choice == 6:
            current += self.unlexer.PROPERTY()
        elif choice == 7:
            current += self.unlexer.ELEMENT()
        elif choice == 8:
            current += self.unlexer.TYPE()
        elif choice == 9:
            current += self.unlexer.REPRESENTATION()
        elif choice == 10:
            current += self.reference()
        elif choice == 11:
            current += self.acmePropertyTypeStructure()
        return current
    acmeTypeRef.min_depth = 2

    default_rule = acmeCompUnit

